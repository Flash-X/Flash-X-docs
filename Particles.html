<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Particles Unit &mdash; Flash-X 0.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Monitor Units" href="monitor.html" />
    <link rel="prev" title="Gravity Unit" href="Gravity.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Flash-X
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Overview of Flash-X architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">The Flash-X configuration )</a></li>
<li class="toctree-l1"><a class="reference internal" href="driver.html">Driver Unit</a></li>
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="physics.html">Physics Units</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Hydro.html">Hydrodynamics Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="IncompNS.html">Incompressible Navier-Stokes Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="Eos.html">Equation of State Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="sourceTerms.html">Local Source Terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="Gravity.html">Gravity Unit</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Particles Unit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#time-integration">Time Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#passive-particles">Passive Particles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mesh-particle-mapping">Mesh/Particle Mapping</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quadratic-mesh-mapping">Quadratic Mesh Mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cloud-in-cell-mapping">Cloud in Cell Mapping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-particles-unit">Using the Particles Unit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#particles-runtime-parameters">Particles Runtime Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#particle-attributes">Particle Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#particle-i-o">Particle I/O</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monitor.html">Monitor Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Flash-X</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="physics.html">Physics Units</a> &raquo;</li>
      <li>Particles Unit</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Particles.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="particles-unit">
<span id="chp-particles"></span><h1>Particles Unit<a class="headerlink" href="#particles-unit" title="Permalink to this headline"></a></h1>
<p>The support for particles in Flash-X will eventually be in two flavors,
<em>active</em> and <em>passive</em>. This version only supports passive particles.
Passive particles acquire their kinematic information (velocities)
directly from the mesh. They are meant to be used as passive flow
tracers and do not make sense outside of a hydrodynamical context. The
governing equation for the <span class="math notranslate nohighlight">\(i\)</span>th passive particle is
particularly simple and requires only the time integration of
interpolated mesh velocities.</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:particle_motion_velocity}
{d{\bf x}_i\over dt}    =  {\bf v}_i\]</div>
<p>Active particles experience forces and may themselves contribute to the
problem dynamics (<em>e.g.</em>, through long-range forces or through
collisions). They may additionally have their own motion independent of
the grid, so an additional motion equation of</p>
<div class="math notranslate nohighlight">
\[\label{Eq:particle_motion_acceleration}
      {\bf v}_i^{n+1} = {\bf v}_i^n + {\bf a}_i^n\Delta t^n ~.\]</div>
<p>may come into play. Here <span class="math notranslate nohighlight">\({\bf a}_i\)</span> is the particle acceleration.
Solving for the motion of active particles is also referred to as
solving the <span class="math notranslate nohighlight">\(N\)</span>-body problem. The equations of motion for the
<span class="math notranslate nohighlight">\(i\)</span>th active particle include the equation
<a class="reference external" href="#Eqn:particle_motion_velocity">[Eqn:particle_motion_velocity]</a> and
another describing the effects of forces.</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:particle_motion_forces}
m_i{d{\bf v}_i\over dt} =  {\bf F}_{{\rm lr,}i} + {\bf F}_{{\rm sr,}i}\ ,\]</div>
<p>Here, <span class="math notranslate nohighlight">\({\bf F}_{{\rm lr,}i}\)</span> represents the sum of all long-range
forces (coupling all particles, except possibly those handled by the
short-range term) acting on the <span class="math notranslate nohighlight">\(i\)</span>th particle and
<span class="math notranslate nohighlight">\({\bf F}_{{\rm sr,}i}\)</span> represents the sum of all short-range
forces (coupling only neighboring particles) acting on the particle.</p>
<p>For both types of particles, the primary challenge is to integrate
<a class="reference external" href="#Eqn:particle_motion_velocity">[Eqn:particle_motion_velocity]</a>
forward through time. Many alternative integration methods are described
in Section  below. Additional information about the mesh to particle
mapping is described in . An introduction to the particle techniques
used in Flash-X is given by R. W. Hockney and J. W. Eastwood in
<em>Computer Simulation using Particles</em> (Taylor and Francis, 1988).</p>
<section id="time-integration">
<span id="sec-particles-integration"></span><h2>Time Integration<a class="headerlink" href="#time-integration" title="Permalink to this headline"></a></h2>
<p>The passive particles have many different time integration schemes
available. The subroutine <code class="docutils literal notranslate"><span class="pre">Particles/Particles_advance</span></code> handles the
movement of particles through space and time. Because Flash-X will have
support for including different types of both active and passive
particles in a single simulation, the implementation of
<code class="docutils literal notranslate"><span class="pre">Particles/Particles_advance</span></code> may call several helper routines of the
form <code class="docutils literal notranslate"><span class="pre">pt_advanceMETHOD</span></code> (<em>e.g.</em>, <code class="docutils literal notranslate"><span class="pre">pt_advanceLeapfrog</span></code>,
<code class="docutils literal notranslate"><span class="pre">pt_advanceEuler_active</span></code>, <code class="docutils literal notranslate"><span class="pre">pt_advanceCustom</span></code>), each acting on an
appropriate subset of existing particles. The <em>METHOD</em> here is
determined by the <code class="docutils literal notranslate"><span class="pre">ADVMETHOD</span></code> part of the <code class="docutils literal notranslate"><span class="pre">PARTICLETYPE</span></code> <code class="docutils literal notranslate"><span class="pre">Config</span></code>
statement (or the <code class="docutils literal notranslate"><span class="pre">ADV</span></code> par of a <code class="docutils literal notranslate"><span class="pre">-particlemethods</span></code> option) for the
type of particle. See the <code class="docutils literal notranslate"><span class="pre">Particles_advance</span></code> source code for the
mapping from <code class="docutils literal notranslate"><span class="pre">ADVMETHOD</span></code> keyword to <code class="docutils literal notranslate"><span class="pre">pt_advanceMETHOD</span></code> subroutine
call.</p>
<section id="passive-particles">
<span id="sec-passive-partices-integration"></span><h3>Passive Particles<a class="headerlink" href="#passive-particles" title="Permalink to this headline"></a></h3>
<p>Passive particles may be moved using one of several different methods
available in Flash-X. With the exception of <strong>Midpoint</strong>, they are all
single-step schemes. The methods are either first-order or second-order
accurate, and all are explicit, as described below. In all
implementations, particle velocities are obtained by mapping grid-based
velocities onto particle positions as described in .</p>
<p>Numerically solving
Equation <a class="reference external" href="#Eqn:particle_motion_velocity">[Eqn:particle_motion_velocity]</a>
for passive particles means solving a set of simple ODE initial value
problems, separately for each particle, where the velocities
<span class="math notranslate nohighlight">\({\bf v}_i\)</span> are given at certain discrete points in time by the
state of the hydrodynamic velocity field at those times. The time step
is thus externally given and cannot be arbitrarily chosen by a particle
motion ODE solver <a class="footnote-reference brackets" href="#id3" id="id1">1</a>. Statements about the order of a method in this
context should be understood as referring to the same method if it were
applied in a hypothetical simulation where evaluations of velocities
<span class="math notranslate nohighlight">\({\bf v}_i\)</span> could be performed at arbitrary times (and with
unlimited accuracy). Note that Flash-X does not attempt to provide a
particle motion ODE solver of higher accuracy than second order, since
it makes little sense to integrate particle motion to a higher order
than the fluid dynamics that provide its inputs.</p>
<p>In all cases, particles are advanced in time from <span class="math notranslate nohighlight">\(t^n\)</span> (or, in
the case of <code class="docutils literal notranslate"><span class="pre">Midpoint</span></code>, from <span class="math notranslate nohighlight">\(t^{n-1}\)</span>) to
<span class="math notranslate nohighlight">\(t^{n+1} = t^n + \Delta
t^n\)</span> using one of the difference equations described below. The
implementations assume that at the time when
<code class="docutils literal notranslate"><span class="pre">Particles/Particles_advance</span></code> is called, the fluid fields have already
been updated to <span class="math notranslate nohighlight">\(t^{n+1}\)</span>, as is the case with the
<code class="docutils literal notranslate"><span class="pre">Driver/Driver_evolveFlash</span></code> implementations provided with Flash-X. A
specific implementation of the passive portion of
<code class="docutils literal notranslate"><span class="pre">Particles/Particles_advance</span></code> is selected by a setup option such as
<code class="docutils literal notranslate"><span class="pre">-with-unit=Particles/ParticlesMain/passive/Euler</span></code>, or by specifying
something like <code class="docutils literal notranslate"><span class="pre">REQUIRES</span> <span class="pre">Particles/ParticlesMain/passive/Euler</span></code> in a
simulation’s <code class="docutils literal notranslate"><span class="pre">Config</span></code> file (or by listing the path in the <code class="docutils literal notranslate"><span class="pre">Units</span></code>
file if not using the <code class="docutils literal notranslate"><span class="pre">-auto</span></code> configuration option). Further details
are given is below.</p>
<ul>
<li><p><strong>Forward Euler (``Particles/ParticlesMain/passive/Euler``).</strong>
Particles are advanced in time from <span class="math notranslate nohighlight">\(t^n\)</span> to
<span class="math notranslate nohighlight">\(t^{n+1} = t^n + \Delta t^n\)</span> using the following difference
equation:</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:particle_passive_euler}
      {\bf x}_i^{n+1} = {\bf x}_i^n + {\bf v}_i^n\Delta t^n \quad.\]</div>
<p>Here <span class="math notranslate nohighlight">\({\bf v}_i^n\)</span> is the velocity of the particle, which is
obtained using particle-mesh interpolation from the grid at
<span class="math notranslate nohighlight">\(t=t^n\)</span>.</p>
<p>Note that this evaluation of <span class="math notranslate nohighlight">\({\bf v}_i^n\)</span> cannot be deferred
until the time when it is needed at <span class="math notranslate nohighlight">\(t=t^{n+1}\)</span>, since at that
point the fluid variables have been updated and the velocity fields
at <span class="math notranslate nohighlight">\(t=t^n\)</span> are not available any more. Particle velocities are
therefore interpolated from the mesh at <span class="math notranslate nohighlight">\(t=t^n\)</span> and stored as
particle attributes. Similar concerns apply to the remaining methods
but will not be explicitly mentioned every time.</p>
</li>
<li><p><strong>Two-Stage Runge-Kutta
(``Particles/ParticlesMain/passive/RungeKutta``).</strong> This 2-stage
Runge-Kutta scheme is the preferred choice in Flash-X. It is also the
default which is compiled in if particles are included in the setup
but no specific alternative implementation is requested. The scheme
is also known as Heun’s Method:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \label{Eqn:particle_passive_rk2}
      {\bf x}_i^{n+1} &amp;=&amp; {\bf x}_i^n + \frac{\Delta t^n}{2}
                     \left[ {\bf v}_i^n + {\bf v}_i^{*,n+1} \right]      \;,\\
      \hbox{where}\quad {\bf v}_i^{*,n+1} &amp;=&amp; {\bf v}({\bf x}_i^{*,n+1},t^{n+1})    \;,\nonumber\\
      {\bf x}_i^{*,n+1} &amp;=&amp; {\bf x}_i^n + \Delta t^n
                     {\bf v}_i^n       \quad.\nonumber
      \end{aligned}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\({\bf v}({\bf x},t)\)</span> denotes evaluation (interpolation) of
the fluid velocity field at position <span class="math notranslate nohighlight">\(\bf x\)</span> and time
<span class="math notranslate nohighlight">\(t\)</span>; <span class="math notranslate nohighlight">\({\bf v}_i^{*,n+1}\)</span> and <span class="math notranslate nohighlight">\({\bf x}_i^{*,n+1}\)</span>
are intermediate results  <a class="footnote-reference brackets" href="#id4" id="id2">2</a>; and
<span class="math notranslate nohighlight">\({\bf v}_i^n = {\bf v}({\bf x}_i^{n},t^{n})\)</span> is the velocity of
the particle, obtained using particle-mesh interpolation from the
grid at <span class="math notranslate nohighlight">\(t=t^n\)</span> as usual.</p>
</li>
<li><p><strong>Midpoint (``Particles/ParticlesMain/passive/Midpoint``).</strong> This
Midpoint scheme is a two-step scheme. Here, the particles are
advanced from time <span class="math notranslate nohighlight">\(t^{n-1}\)</span> to
<span class="math notranslate nohighlight">\(t^{n+1} = t^{n-1} + \Delta t^{n-1} + \Delta t^{n}\)</span> by the
equation</p>
<div class="math notranslate nohighlight">
\[{\bf x}_i^{n+1} = {\bf x}_i^{n-1} + {\bf v}_i^{n}(\Delta t^{n-1} + \Delta t^{n}) \quad.\]</div>
<p>The scheme is second order if <span class="math notranslate nohighlight">\(\Delta t^n = \Delta t^{n-1}\)</span>.</p>
<p>To get the scheme started, an Euler step (as described for
<code class="docutils literal notranslate"><span class="pre">passive/Euler</span></code>) is taken the first time
<code class="docutils literal notranslate"><span class="pre">Particles/ParticlesMain/passive/Midpoint/pt_advancePassive</span></code> is
called.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Midpoint</span></code> alternative implementation uses the following
additional particle attributes:</p>
<div class="codeseg docutils container">
<p>PARTICLEPROP pos2PrevX REAL # two previous x-coordinate
PARTICLEPROP pos2PrevY REAL # two previous y-coordinate
PARTICLEPROP pos2PrevZ REAL # two previous z-coordinate</p>
</div>
</li>
<li><p><strong>Estimated Midpoint with Correction
(``Particles/ParticlesMain/passive/EstiMidpoint2``).</strong> The scheme is
second order even if <span class="math notranslate nohighlight">\(\Delta t^n = \Delta t^{n+1}\)</span> is not
assumed. It is essentially the <code class="docutils literal notranslate"><span class="pre">EstiMidpoint</span></code> or
“Predictor-Corrector” method of previous releases, with a correction
for non-constant time steps by using additional evaluations (at times
and positions that are easily available, without requiring more
particle attributes).</p>
<p>Particle advancement follows the equation ‘_=8 ‘_=8</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:EstiMidpoint2}
{\bf x}_i^{n+1} = {\bf x}_i^n +   {{\Delta t}}^n \, {\bf v}_i^{\mathrm{comb}}\;,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:pt_em2-2}
{\bf v}_i^{\mathrm{comb}}=
c_1\,{\bf v}({\bf x}_i^{*,n+\frac 12},t^{n})   +
c_2\,{\bf v}({\bf x}_i^{*,n+\frac 12},t^{n+1})   +
c_3\,{\bf v}({\bf x}_i^{n},t^{n})   +
c_4\,{\bf v}({\bf x}_i^{n},t^{n+1})\]</div>
<p>is a combination of four evaluations (two each at the previous and
the current time),</p>
<div class="math notranslate nohighlight">
\[{\bf x}_i^{*,n+\frac 12}= {\bf x}_i^n + \frac12 \Delta t^{n-1} {\bf v}_i^n\]</div>
<p>are estimated midpoint positions as before in the Estimated Midpoint
scheme, and the coefficients</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
c_1&amp;=&amp;c_1({\Delta t}^{n-1},{\Delta t}^n)\;,\\
c_2&amp;=&amp;c_2({\Delta t}^{n-1},{\Delta t}^n)\;,\\
c_3&amp;=&amp;c_3({\Delta t}^{n-1},{\Delta t}^n)\;,\\
c_4&amp;=&amp;c_4({\Delta t}^{n-1},{\Delta t}^n)\end{aligned}\end{split}\]</div>
<p>are chosen dependent on the change in time step so that the method
stays second order when <span class="math notranslate nohighlight">\({\Delta t}^{n-1} \neq {\Delta t}^n\)</span>.</p>
<p>Conditions for the correction can be derived as follows: Let
<span class="math notranslate nohighlight">\(\Delta t_{*}^{n} =\frac 12 \Delta t^{n-1}\)</span> the estimated half
time step used in the scheme, let
<span class="math notranslate nohighlight">\(t_{*}^{n+\frac 12}=t^n + \Delta t_{*}^{n}\)</span> the estimated
midpoint time, and <span class="math notranslate nohighlight">\(t^{n+\frac 12}=t^n + \frac 12 \Delta t^{n}\)</span>
the actual midpoint of the <span class="math notranslate nohighlight">\([t^n,t^{n+1}]\)</span> interval. Also write
<span class="math notranslate nohighlight">\({\bf x}_i^{{\mathrm{E}},n+\frac 12}= {\bf x}_i^{n}+ \frac 12 \Delta t^{n}{\bf v}_i^{n}\)</span>
for first-order (Euler) approximate positions at the actual midpoint
time <span class="math notranslate nohighlight">\(t^{n+\frac 12}\)</span>, and we continue to denote with
<span class="math notranslate nohighlight">\({\bf x}_i^{*,n+\frac 12}\)</span> the estimated positions reached at
the estimated mipoint time <span class="math notranslate nohighlight">\(t_{*}^{n+\frac 12}\)</span>.</p>
<p>Assuming reasonably smooth functions <span class="math notranslate nohighlight">\({\bf v}({\bf x},t)\)</span>, we
can then write for the exact value of the velocity field at the
approximate positions evaluated at the actual midpoint time</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:vhalf_expansion}
{\bf v}({\bf x}_i^{{\mathrm{E}},n+\frac 12},t^{n+\frac 12}) =
   {\bf v}({\bf x}_i^{n},t^{n}) +
      {\bf v}_t({\bf x}_i^{n},t^{n})\frac 12 \Delta t^{n}+
      ({\bf v}_i^{n}\cdot \frac{\partial}{\partial {\bf x}}) {\bf v}({\bf x}_i^{n},t^{n})\frac 12 \Delta t^{n}+
         O((\frac 12 \Delta t^{n})^2)\]</div>
<p>by Taylor expansion. It is known that the propagation scheme
<span class="math notranslate nohighlight">\(\widetilde{{\bf x}}_i^{n+1}={\bf x}_i^{n}+{\bf v}({\bf x}_i^{{\mathrm{E}},n+\frac 12},t^{n+\frac 12}) {\Delta t}\)</span>
using these velocities is second order (this is known as the modified
Euler method).</p>
<p>On the other hand, expansion of <a class="reference external" href="#Eqn:pt_em2-2">[Eqn:pt_em2-2]</a>
gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
{\bf v}_i^{\mathrm{comb}}&amp;=&amp;
(c_1+c_2+c_3+c_4) {\bf v}({\bf x}_i^{n},t^{n}) \nonumber\\
&amp;&amp; +\;
   (c_2+    c_4) {\bf v}_t({\bf x}_i^{n},t^{n}) {\Delta t}\;+\;
  (c_1+c_2)  ({\bf v}_i^{n}\cdot \frac{\partial}{\partial {\bf x}}) {\bf v}({\bf x}_i^{n},t^{n}) \Delta t_{*}^{n} \nonumber\\
&amp;&amp; \quad +    \quad    \mbox{higher order terms in ${\Delta t}$ and $\Delta t_{*}^{n} $.} \nonumber\end{aligned}\end{split}\]</div>
<p>After introducing a time step factor <span class="math notranslate nohighlight">\(f\)</span> defined by
<span class="math notranslate nohighlight">\(\Delta t_{*}^{n} = f\,{\Delta t}^{n}\)</span>, this becomes</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \label{Eqn:vcomb_expansion}
{\bf v}_i^{\mathrm{comb}}&amp;=&amp;
(c_1+c_2+c_3+c_4) {\bf v}({\bf x}_i^{n},t^{n}) \\
&amp;&amp; +\;
   (c_2+    c_4) {\bf v}_t({\bf x}_i^{n},t^{n}) {\Delta t}\;+\;
  (c_1+c_2)({\bf v}_i^{n}\cdot \frac{\partial}{\partial {\bf x}}) {\bf v}({\bf x}_i^{n},t^{n}) \,f\,{\Delta t}\nonumber\\
&amp;&amp; \quad  +  \; O(({\Delta t})^2)\quad. \nonumber\end{aligned}\end{split}\]</div>
<p>One can derive conditions for second order accuracy by comparing
<a class="reference external" href="#Eqn:vcomb_expansion">[Eqn:vcomb_expansion]</a> with
<a class="reference external" href="#Eqn:vhalf_expansion">[Eqn:vhalf_expansion]</a> and requiring that</p>
<div class="math notranslate nohighlight">
\[{\bf v}_i^{\mathrm{comb}}=  {\bf v}({\bf x}_i^{{\mathrm{E}},n+\frac 12},t^{n+\frac 12}) +  O(({\Delta t})^2)\quad.\]</div>
<p>It turns out that the coefficients have to satisfy three conditions
in order to eliminate from the theoretical difference between
numerical and exact solution all <span class="math notranslate nohighlight">\(O({\Delta t}^{n-1})\)</span> and
<span class="math notranslate nohighlight">\(O({\Delta t}^{n})\)</span> error terms:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
   c_1+c_2+c_3+c_4&amp;=&amp; 1  \quad  \mbox{(otherwise the scheme will not even be of first order)}\;,\\
      c_2+c_4&amp;=&amp; \frac12 \quad  \mbox{(and thus also $c_1+c_3=\frac12$)}\;, \\
   c_1+c_2&amp;=&amp; \frac{ {\Delta t}^n } { {\Delta t}^{n-1} } \quad.\end{aligned}\end{split}\]</div>
<p>The provided implementation chooses <span class="math notranslate nohighlight">\(c_4=0\)</span> (this can be easily
changed if desired by editing in the code). All four coefficients are
then determined:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
c_1&amp;=&amp;\frac{ {\Delta t}^n } { {\Delta t}^{n-1} } - \frac12\;,\\
c_2&amp;=&amp;\frac12\;,\\
c_3&amp;=&amp;1 - \frac{ {\Delta t}^n } { {\Delta t}^{n-1} }\;,\\
c_4&amp;=&amp;0\quad.
      \end{aligned}\end{split}\]</div>
<p>Note that when the time step remains unchanged we have
<span class="math notranslate nohighlight">\(c_1=c_2=\frac12\)</span> and <span class="math notranslate nohighlight">\(c_3=c_4=0\)</span>, and so
<a class="reference external" href="#Eqn:EstiMidpoint2">[Eqn:EstiMidpoint2]</a> simplifies
significantly.</p>
<p>An Euler step, as described for <code class="docutils literal notranslate"><span class="pre">passive/Euler</span></code> in
<a class="reference external" href="#Eqn:particle_passive_euler">[Eqn:particle_passive_euler]</a>, is
taken the first time when
<code class="docutils literal notranslate"><span class="pre">Particles/ParticlesMain/passive/EstiMidpoint2/pt_advancePassive</span></code>
is called and when the time step has changed too much. Since the
integration scheme is tolerant of time step changes, it should
usually not be necessary to apply the second criterion; even when it
is to be employed, the criteria should be less strict than for an
uncorrected <code class="docutils literal notranslate"><span class="pre">EstiMidpoint</span></code> scheme. For <code class="docutils literal notranslate"><span class="pre">EstiMidPoint2</span></code> the
timestep is considered to have changed too much if either of the
following is true:</p>
<div class="math notranslate nohighlight">
\[\Delta t^{n} &gt; \Delta t^{n-1}
\quad\mbox{and}\quad
    \left| \Delta t^{n} - \Delta t^{n-1} \right| \geq
                                                      {\tt pt\_dtChangeToleranceUp} \times  \Delta t^{n-1}\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[\Delta t^{n} &lt; \Delta t^{n-1}
\quad\mbox{and}\quad
    \left| \Delta t^{n} - \Delta t^{n-1} \right| \geq
                                                      {\tt pt\_dtChangeToleranceDown} \times  \Delta t^{n-1},\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Particles/pt_dtChangeToleranceUp</span></code> and
<code class="docutils literal notranslate"><span class="pre">Particles/pt_dtChangeToleranceDown</span></code> are runtime parameter specific
to the <code class="docutils literal notranslate"><span class="pre">EstiMidPoint2</span></code> alternative implementation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">EstiMidpoint2</span></code> alternative implementation uses the following
additional particle attributes for storing the values of
<span class="math notranslate nohighlight">\({\bf x}_i^{*,n+\frac 12}\)</span> and <span class="math notranslate nohighlight">\({\bf v}_i^{*,n+\frac 12}\)</span>
between the <code class="docutils literal notranslate"><span class="pre">Particles_advance</span></code> calls at <span class="math notranslate nohighlight">\(t^n\)</span> and
<span class="math notranslate nohighlight">\(t^{n+1}\)</span>:</p>
<div class="codeseg docutils container">
<p>PARTICLEPROP velPredX REAL PARTICLEPROP velPredY REAL PARTICLEPROP
velPredZ REAL PARTICLEPROP posPredX REAL PARTICLEPROP posPredY
REAL PARTICLEPROP posPredZ REAL</p>
</div>
</li>
</ul>
<p>The time integration of passive particles is tested in the
<code class="docutils literal notranslate"><span class="pre">ParticlesAdvance</span></code> unit test, which can be used to examine the
convergence behavior, see .</p>
</section>
</section>
<section id="mesh-particle-mapping">
<span id="sec-particles-mapping"></span><h2>Mesh/Particle Mapping<a class="headerlink" href="#mesh-particle-mapping" title="Permalink to this headline"></a></h2>
<p>Particles behave in a fundamentally different way than grid-based
quantities. Lagrangian, or passive particles are essentially independent
of the grid mesh and move along with the velocity field. Active
particles may be located independently of mesh refinement. In either
case, there is a need to convert grid-based quantities into similar
attributes defined on particles, or vice versa. The method for
interpolating mesh quantities to tracer particle positions must be
consistent with the numerical method to avoid introducing systematic
error. In the case of a finite-volume methods such as those used in
Flash-X, the mesh quantities have cell-averaged rather than point
values, which requires that the interpolation function for the particles
also represent cell-averaged values. Cell averaged quantities are
defined as</p>
<div class="math notranslate nohighlight">
\[f_i\left(x\right) \: \equiv \: \frac{1}{\Delta x} \int_{x_{i-1/2}}^{x_{i-1/2}}
f\left(x^\prime \right) dx^\prime\]</div>
<p>where <span class="math notranslate nohighlight">\(i\)</span> is the cell index and <span class="math notranslate nohighlight">\(\Delta x\)</span> is the spatial
resolution. The mapping back and forth from the mesh to the particle
properties are defined in the routines <code class="docutils literal notranslate"><span class="pre">Particles_mapFromMesh</span></code> and
<code class="docutils literal notranslate"><span class="pre">Particles_mapToMeshOneBlk</span></code>.</p>
<p>Specifying the desired mapping method is accomplished by designating the
<code class="docutils literal notranslate"><span class="pre">MAPMETHOD</span></code> in the Simulation <code class="docutils literal notranslate"><span class="pre">Config</span></code> file for each type of
particle. See for more details.</p>
<section id="quadratic-mesh-mapping">
<h3>Quadratic Mesh Mapping<a class="headerlink" href="#quadratic-mesh-mapping" title="Permalink to this headline"></a></h3>
<p>The quadratic mapping package defines an interpolation back and forth to
the mesh which is second order. This implementation is primarily meant
to be used with passive tracer particles.</p>
<p>To derive it, first consider a second-order interpolation function of
the form</p>
<div class="math notranslate nohighlight">
\[f\left(x\right) \: = \: A + B \left(x - x_i\right) + C \left(x - x_i\right)^2 \; .\]</div>
<p>Then integrating gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
f_{i-1} \: &amp; = &amp; \: \frac{1}{\Delta x}\left[ A + \left. \frac{1}{2}
B \left(x - x_i\right)^2 \right|^{x_{i-1/2}}_{x_{i-3/2}} + \left. \frac{1}{3}
C \left(x - x_i\right)^3 \right|^{x_{i-1/2}}_{x_{i-3/2}} \right]\nonumber  \\
           &amp; = &amp; \: A - B\Delta x + \frac{13}{12} C \Delta x^2 \;,\end{aligned}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
f_{i} \: &amp; = &amp; \: \frac{1}{\Delta x}\left[ A + \left. \frac{1}{2} B \left(x - x_i\right)^2 \right|^{x_{i+1/2}}_{x_{i-1/2}}
+ \left. \frac{1}{3}  C \left(x - x_i\right)^3 \right|^{x_{i+1/2}}_{x_{i-1/2}}  \right]\nonumber \\
           &amp; = &amp; \: A + \frac{1}{12} C \Delta x^2 \; ,\end{aligned}\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
f_{i+1} \: &amp; = &amp; \: \frac{1}{\Delta x}\left[ A + \left.\frac{1}{2} B \left(x - x_i\right)^2 \right|^{x_{i+3/2}}_{x_{i+1/2}}.
+ \left. \frac{1}{3}  C \left(x - x_i\right)^3 \right|^{x_{i-1/2}}_{x_{i-3/2}} \right]\nonumber  \\
           &amp; = &amp; \: A - B\Delta x + \frac{13}{12} C \Delta x^2 \;,\end{aligned}\end{split}\]</div>
<p>We may write these as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{c}
f_{i+1} \\ f_{i} \\ f_{i-1}
\end{array} \right] \: = \:
\left[ \begin{array}{ccc}
1 &amp; -1 &amp; \frac{13}{12} \\ 1 &amp; 0 &amp; \frac{1}{12} \\ 1 &amp; 1 &amp; \frac{13}{12}
\end{array} \right]
\left[ \begin{array}{ccc}
A \\ B\Delta x \\ C \Delta x^2
\end{array} \right] \; .\end{split}\]</div>
<p>Inverting this gives expressions for <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, and
<span class="math notranslate nohighlight">\(C\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2
\end{array} \right] \: = \:
\left[ \begin{array}{ccc}
-\frac{1}{24} &amp; \frac{13}{12} &amp; -\frac{1}{24} \\ -\frac{1}{2} &amp; 0 &amp; \frac{1}{2} \\
\frac{1}{2} &amp; -1 &amp; \frac{1}{2}
\end{array} \right]
\left[ \begin{array}{ccc}
f_{i+1} \\ f_{i} \\ f_{i-1}
\end{array} \right] \; .\end{split}\]</div>
<p>In two dimensions, we want a second-order interpolation function of the
form</p>
<div class="math notranslate nohighlight">
\[f\left(x,y\right) \: = \: A + B \left(x - x_i\right) + C \left(x - x_i\right)^2
+ D \left(y - y_j\right) + E \left(y - y_j\right)^2 +
F \left(x - x_i\right)\left(y - y_j\right) \; .\]</div>
<p>In this case, the cell averaged quantities are given by</p>
<div class="math notranslate nohighlight">
\[f_{i,j}\left(x,y\right) \: \equiv \: \frac{1}{\Delta y}{\Delta x} \int_{x_{i-1/2}}^{x_{i+1/2}}
dx^\prime
\int_{y_{j-1/2}}^{x_{j-1/2}}  dy^\prime
f\left(x^\prime,y^\prime \right) \; .\]</div>
<p>Integrating the 9 possible cell averages gives, after some algebra,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{c}
f_{i-1,j-1} \\ f_{i,j-1} \\ f_{i+1,j-1} \\
f_{i-1,j} \\ f_{i,j} \\ f_{i+1,j} \\
f_{i-1,j+1} \\ f_{i,j+1} \\ f_{i+1,j+1}
\end{array} \right] \: = \:
\left[ \begin{array}{cccccc}
1 &amp; -1 &amp; \frac{13}{12} &amp; -1 &amp;  \frac{13}{12} &amp;  1 \\
1 &amp;  0 &amp; \frac{1}{12}  &amp; -1 &amp;  \frac{13}{12} &amp;  0 \\
1 &amp;  1 &amp; \frac{13}{12} &amp; -1 &amp;  \frac{13}{12} &amp; -1 \\
1 &amp; -1 &amp; \frac{13}{12} &amp;  0 &amp;  \frac{1}{12}  &amp;  0 \\
1 &amp;  0 &amp; \frac{1}{12}  &amp;  0 &amp;  \frac{1}{12}  &amp;  0 \\
1 &amp;  1 &amp; \frac{13}{12} &amp;  0 &amp;  \frac{1}{12}  &amp;  0 \\
1 &amp; -1 &amp; \frac{13}{12} &amp;  1 &amp;  \frac{13}{12} &amp; -1 \\
1 &amp;  0 &amp; \frac{1}{12}  &amp;  1 &amp;  \frac{13}{12} &amp;  0 \\
1 &amp;  1 &amp; \frac{13}{12} &amp;  1 &amp;  \frac{13}{12} &amp;  1
\end{array} \right]
\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2 \\
D \Delta y \\ E \Delta y^2 \\ F \Delta x \Delta y
\end{array} \right] \; .\end{split}\]</div>
<p>At this point we note that there are more constraints than unknowns, and
we must make a choice of the constraints. We chose to ignore the cross
terms and take only the face-centered cells next to the cell containing
the particle, giving</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{c}
f_{i,j-1} \\ f_{i-1,j} \\ f_{i,j} \\
f_{i+1,j} \\ f_{i,j+1}
\end{array} \right] \: = \:
\left[ \begin{array}{cccccc}
1 &amp;  0 &amp; \frac{1}{12}  &amp; -1 &amp;  \frac{13}{12}  \\
1 &amp; -1 &amp; \frac{13}{12} &amp;  0 &amp;  \frac{1}{12}   \\
1 &amp;  0 &amp; \frac{1}{12}  &amp;  0 &amp;  \frac{1}{12}   \\
1 &amp;  1 &amp; \frac{13}{12} &amp;  0 &amp;  \frac{1}{12}   \\
1 &amp;  0 &amp; \frac{1}{12}  &amp;  1 &amp;  \frac{13}{12}
\end{array} \right]
\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2 \\
D \Delta y \\ E \Delta y^2
\end{array} \right] \; .\end{split}\]</div>
<p>Inverting gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2 \\
D \Delta y \\ E \Delta y^2
\end{array} \right]
\: = \:
\left[ \begin{array}{cccccc}
-\frac{1}{24} &amp; -\frac{1}{24}  &amp; \frac{7}{6}  &amp; -\frac{1}{24}  &amp; -\frac{1}{24}  \\
0             &amp; -\frac{1}{2}   &amp; 0            &amp;  \frac{1}{2}   &amp;  0   \\
0             &amp; \frac{1}{2}    &amp; -1           &amp;  \frac{1}{2}   &amp;  0   \\
-\frac{1}{2}  &amp;  0             &amp; 0            &amp;  0             &amp;  \frac{1}{2}   \\
\frac{1}{2}    &amp;  0             &amp; -1           &amp;  0             &amp;  \frac{1}{2}
\end{array} \right]
\left[ \begin{array}{c}
f_{i,j-1} \\ f_{i-1,j} \\ f_{i,j} \\
f_{i+1,j} \\ f_{i,j+1}
\end{array} \right]  \; .\end{split}\]</div>
<p>Similarly, in three dimensions, the interpolation function is</p>
<div class="math notranslate nohighlight">
\[f\left(x,y,z\right) \: = \: A + B \left(x - x_i\right) + C \left(x - x_i\right)^2
+ D \left(y - y_j\right) + E \left(y - y_j\right)^2 +
F \left(z - z_k\right) + G  \left(z - z_k\right)^2 \; .\]</div>
<p>and we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{c}
A \\ B \Delta x \\ C {\Delta x}^2 \\
D \Delta y \\ E {\Delta y}^2 \\ F \Delta z \\ G {\Delta z}^2
\end{array} \right]
\: = \:
\left[ \begin{array}{ccccccc}
-\frac{1}{24} &amp; -\frac{1}{24} &amp; -\frac{1}{24} &amp; \frac{5}{4} &amp; -\frac{1}{24} &amp; -\frac{1}{24} &amp; -\frac{1}{24} \\
0             &amp; 0             &amp; -\frac{1}{2}  &amp; 0           &amp;  \frac{1}{2}  &amp; 0             &amp;  0   \\
0             &amp; 0             &amp;  \frac{1}{2}  &amp; -1          &amp;  \frac{1}{2}  &amp; 0             &amp;  0   \\
0             &amp; -\frac{1}{2}  &amp;  0            &amp;  0          &amp;  0            &amp; \frac{1}{2}   &amp;  0   \\
0             &amp;  \frac{1}{2}  &amp;  0            &amp; -1          &amp;  0            &amp; \frac{1}{2}   &amp;  0   \\
-\frac{1}{2}  &amp; 0             &amp;  0            &amp;  0          &amp;  0            &amp; 0             &amp;  \frac{1}{2}   \\
 \frac{1}{2}  &amp; 0             &amp;  0            &amp; -1          &amp;  0            &amp; 0             &amp;  \frac{1}{2}
\end{array} \right]
\left[ \begin{array}{c}
f_{i,j,k-1} \\ f_{i,j-1,k} \\ f_{-i,j,k} \\
f_{i,j,k} \\ f_{i+1,j,k} \\ f_{i,j+1,k} \\ f_{i,j,k+1}
\end{array} \right]  \; .\end{split}\]</div>
<p>Finally, the above expressions apply only to Cartesian coordinates. In
the case of cylindrical <span class="math notranslate nohighlight">\(\left(r,z\right)\)</span> coordinates, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
f\left(r,z\right) \; = &amp; &amp; \nonumber \\
&amp; A + B \left(r - r_i\right) + C \left(r - r_i\right)^2
+ D \left(z - z_j\right) &amp; \nonumber \\
&amp; + E \left(z - z_j\right)^2 +
F \left(r - r_i\right)\left(z - z_j\right) \; . &amp;\end{aligned}\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\left[ \begin{array}{c}
A \\ B\Delta r \\ C\Delta r^{\frac{2}{6}} \\ D\Delta z  \\ E \Delta z^2
\end{array} \right] \: = \hspace{-1.0in} &amp; &amp; \nonumber \\
&amp; \left[ \begin{array}{cccccc}
-\frac{1}{24} &amp; -\frac{h_1-1}{24h_1}  &amp; \frac{7}{6}      &amp; -\frac{h_1-1}{24h1}  &amp; -\frac{1}{24} \\
0
&amp; - \frac{\left(7+6h_1\right)\left(h_1-1\right)}{3h_2}
&amp; \frac{2h_1}{3h2}
&amp; \frac{\left(7+6h_1\right)\left(h_1-1\right)}{3h_2}
&amp; 0  \\
0
&amp; \frac{\left(12h_1^2 + 12 h_1 - 1\right)\left(h_1 - 1\right)}{h_1h_2}
&amp; -2 \frac{12 h_1^2 -13}{h_2}
&amp; - \frac{\left(12h_1^2 + 12 h_1 - 1\right)\left(h_1 - 1\right)}{h_1h_2}
&amp; 0 \\
- \frac{1}{2}
&amp; 0
&amp; 0
&amp; \frac{1}{2}
&amp; 0 \\
0
&amp; \frac{1}{2}
&amp; - 1
&amp; \frac{1}{2}
&amp; 0 \\
\end{array} \right]
\left[ \begin{array}{c}
f_{i,j-1} \\ f_{i-1,j} \\ f_{i,j} \\
f_{i+1,j} \\ f_{i,j+1}
\end{array} \right]  \; . &amp;\end{aligned}\end{split}\]</div>
</section>
<section id="cloud-in-cell-mapping">
<span id="sec-cic"></span><h3>Cloud in Cell Mapping<a class="headerlink" href="#cloud-in-cell-mapping" title="Permalink to this headline"></a></h3>
<p>Other interpolation routines can be defined that take into account the
actual quantities defined on the grid. These “mesh-based” algorithms are
represented in Flash-X by the Cloud-in-Cell mapping, where the
interpolation to/from the particles is defined as a simple linear
weighting from nearby grid points. The weights are defined by
considering only the region of one “cell” size around each particle
location; the proportional volume of the particle “cloud” corresponds to
the amount allocated to/from the mesh. The <code class="docutils literal notranslate"><span class="pre">CIC</span></code> method can be used
with both types of particles. When using it with active particles the
MapToMesh methods should also be selected. In order to include the CIC
method with passive particles, the <code class="docutils literal notranslate"><span class="pre">setup</span></code> command line option is
<code class="docutils literal notranslate"><span class="pre">-with-unit=Particles/ParticlesMapping/CIC</span></code>. Two additional command
line option <code class="docutils literal notranslate"><span class="pre">-with-unit=Particles/ParticlesMapping/MapToMesh</span></code> and
<code class="docutils literal notranslate"><span class="pre">-with-unit=Grid/GridParticles/MapToMesh</span></code> are necessary when using the
active particles. All of these command line options can be replaced by
placing the appropriate <code class="docutils literal notranslate"><span class="pre">REQUIRES/REQUESTS</span></code> directives in the
Simulation <code class="docutils literal notranslate"><span class="pre">Config</span></code> file.</p>
</section>
</section>
<section id="using-the-particles-unit">
<span id="sec-particlesusing"></span><h2>Using the Particles Unit<a class="headerlink" href="#using-the-particles-unit" title="Permalink to this headline"></a></h2>
<p>The Particles unit encompasses nearly all aspects of Lagrangian
particles. The exceptions are input/output the movement of related data
structures between different blocks as the particles move from one block
to another, and mapping the particle attributes to and from the grid.</p>
<p>Particle types must be specified in the <code class="docutils literal notranslate"><span class="pre">Config</span></code> file of the
Simulations unit setup directory for the application, and the syntax is
explained in . At configuration time, the setup script parses the
<code class="docutils literal notranslate"><span class="pre">PARTICLETYPE</span></code> specifications in the Config files, and generates an
F90 file <code class="docutils literal notranslate"><span class="pre">Particles/Particles_specifyMethods</span></code><code class="docutils literal notranslate"><span class="pre">.F90</span></code> that populates
a data structure <code class="docutils literal notranslate"><span class="pre">gr_ptTypeInfo</span></code>. This data structure contains
information about the method of initialization and interpolation methods
for mapping the particle attributes to and from the grid for each
included particle type. Different time integration schemes are applied
to active and passive particles. However, in one simulation, all active
particles are integrated using the same scheme, regardless of how many
active types exists. Similarly, only one passive integration scheme is
used. The added complexity of multiple particle types allows different
methods to be used for initialization of particles positions and their
mapping to and from the grid quantities. Because several different
implementations of each type of functionality can co-exist in one
simulation, there are no defaults in the <code class="docutils literal notranslate"><span class="pre">Particles</span></code> unit <code class="docutils literal notranslate"><span class="pre">Config</span></code>
files. These various functionalities are organized into different
subunits; a brief description of each subunit is included below and
further expanded in subsections in this chapter.</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ParticlesInitialization</span></code> subunit distributes a given set of
particles through the spatial domain at the simulation startup. Some
type of spatial initialization is always required; the functionality
is provided by <code class="docutils literal notranslate"><span class="pre">Particles/Particles_initPositions</span></code>. The users of
active particles typically have their own custom initialization. The
following two implementations of initialization techniques are
included in the Flash-X distribution (they are more likely to used
with the passive tracer particles):</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Lattice</span></code></dt><dd><p>distributes particles regularly along the axes directions
throughout a subsection of the physical grid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WithDensity</span></code></dt><dd><p>distributes particles randomly, with particle density being
proportional to the grid gas density.</p>
</dd>
</dl>
<p>Users have two options for implementing custom initialization
methods. The two files involved in the process are:
<code class="docutils literal notranslate"><span class="pre">Particles/Particles_initPositions</span></code> and pt_initPositions. The
former does some housekeeping such as allowing for inclusion of one
of the available methods along with the user specified one, and
assigning tags at the end. A user wishing to add one custom method
with no constraints on tags etc is advised to implement a custom
version of the latter. This approach allows the user to focus the
implementation on the placement of particles only. Users desirous of
refining the grid based on particles count during initialiation
should see the setup <code class="docutils literal notranslate"><span class="pre">PoisParticles</span></code> for an example implementation
of the Particles_initPositions routine. If more than one
implementation of pt_initPositions is desired in the same simulation
then it is necessary to implement each one separately with different
names (as we do for tracer particles: pt_initPositionsLattice and
pt_initPositionsWithDensity) in their simulation setup directory. In
addition, a modified copy of Particles_initPostions, which calls
these new routines in the loop over types, must also be placed in the
same directory.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ParticlesMain</span></code> subunit contains the various time-integration
options for both active and passive particles. A detailed overview of
the different schemes is given in .</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ParticlesMapping</span></code> subunit controls the mapping of particle
properties to and from the grid. Flash-X currently supplies the
following mapping schemes:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Cloud-in-cell</span></code></dt><dd><p>(<code class="docutils literal notranslate"><span class="pre">ParticlesMapping/meshWeighting/CIC</span></code>), which weights values at
nearby grid cells; and</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Quadratic</span></code></dt><dd><p>(<code class="docutils literal notranslate"><span class="pre">ParticlesMapping/Quadratic</span></code>), which performs quadratic
interpolation.</p>
</dd>
</dl>
</li>
</ul>
<p>Some form of mapping must always be included when running a simulation
with particles. As mentioned in the quadratic mapping scheme is only
available to map <em>from</em> the grid quantities to the corresponding
particle attributes. Since active particles require the same mapping
scheme to be used in mapping to and from the mesh, they cannot use the
quadratic mapping scheme as currently implemented in Flash-X. The CIC
scheme may be used by both the active and passive particles.</p>
<p>After particles are moved during time integration or by forces, they may
end up on other blocks within or without the current processor. The
redistribution of particles among processors is handled by the
<code class="docutils literal notranslate"><span class="pre">GridParticles</span></code> subunit, as the algorithms required vary considerably
between the grid implementations. The boundary conditions are also
implemented by the GridParticles unit. See for more details of these
redistribution algorithms. The user should include the option
<code class="docutils literal notranslate"><span class="pre">-with-unit=Grid/GridParticles</span></code> on the setup line, or
<code class="docutils literal notranslate"><span class="pre">REQUIRES</span> <span class="pre">Grid/GridParticles</span></code> in the Config file.</p>
<p>In addition, the input-output routines for the Particles unit are
contained in a subunit <code class="docutils literal notranslate"><span class="pre">IOParticles</span></code>. Particles are written to the
main checkpoint files. If the user desires, a separate output file can
be created which contains only the particle information. See below as
well as for more details. The user should include the option
<code class="docutils literal notranslate"><span class="pre">-with-unit=IO/IOParticles</span></code> on the setup line, or
<code class="docutils literal notranslate"><span class="pre">REQUIRES</span> <span class="pre">IO/IOParticles</span></code> in the Config file.</p>
<p>In Flash-X, the initial particle positions can be used to construct an
appropriately refined grid, i.e. more refined in places where there is a
clustering of particles. To use this feature the <code class="docutils literal notranslate"><span class="pre">flash.par</span></code> file must
include: <code class="docutils literal notranslate"><span class="pre">refine_on_particle_count=.true.</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_particles_per_blk=[some</span> <span class="pre">value]</span></code>. Please be aware that Flash-X
will abort if the criterion is too demanding. To overcome the abort,
specify a less demanding criterion, or increase the value of
<code class="docutils literal notranslate"><span class="pre">lrefine_max</span></code>.</p>
<section id="particles-runtime-parameters">
<span id="sec-particles-runtime-parameters"></span><h3>Particles Runtime Parameters<a class="headerlink" href="#particles-runtime-parameters" title="Permalink to this headline"></a></h3>
<p>There are several general runtime parameters applicable to the
<code class="docutils literal notranslate"><span class="pre">Particles</span></code> unit, which affect every implementation. The variable
<code class="docutils literal notranslate"><span class="pre">Particles/useParticles</span></code> obviously must be set equal to <code class="docutils literal notranslate"><span class="pre">.true.</span></code> to
utilize the Particles unit. The time stepping is controlled with
<code class="docutils literal notranslate"><span class="pre">Particles/pt_dtFactor</span></code>; a value less than one ensures that particles
will not step farther than one entire cell in any given time interval.
The <code class="docutils literal notranslate"><span class="pre">Lattice</span></code> initialization routines have additional parameters. The
number of evenly spaced particles is controlled in each direction by
<code class="docutils literal notranslate"><span class="pre">Particles/pt_numX</span></code> and similar variables in <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>.
The physical range of initialization is controlled by
<code class="docutils literal notranslate"><span class="pre">Particles/pt_initialXMin</span></code> and the like. Finally, note that the output
of particle properties to special particle files is controlled by
runtime parameters found in the <code class="docutils literal notranslate"><span class="pre">IO</span></code> unit. See for more details.</p>
</section>
<section id="particle-attributes">
<span id="sec-particle-properties"></span><h3>Particle Attributes<a class="headerlink" href="#particle-attributes" title="Permalink to this headline"></a></h3>
<p>By default, particles are defined to have eight real properties or
attributes: 3 positions in x,y,z; 3 velocities in x,y,z; the current
block identification number; and a tag which uniquely identifies the
particle. Additional properties can be defined for each particle. For
example, active particles usually have the additional properties of mass
and acceleration (needed for the integration routines, see Table ).
Depending upon the simulation, the user can define particle properties
in a manner similar to that used for mesh-based solution variables. To
define a particle attribute, add to a <code class="docutils literal notranslate"><span class="pre">Config</span></code> file a line of the form</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">PARTICLEPROP</span></code> <em>property-name</em></p>
</div></blockquote>
<p>For attributes that are meant to merely sample and record the state of
certain mesh variables along trajectories, Flash-X can automatically
invoke interpolation (or, in general, some map method) to generate
attribute values from the appropriate grid quantities. (For passive
tracer particles, these are typically the only attributes beyond the
default set of eight mentioned above.) The routine
<code class="docutils literal notranslate"><span class="pre">Particles/Particles_updateAttributes</span></code> is invoked by Flash-X at
appropriate times to effect this mapping, namely before writing particle
data to checkpoint and particle plot files. To direct the default
implementation of <code class="docutils literal notranslate"><span class="pre">Particles_updateAttributes</span></code> to act as desired for
tracer attributes, the user must define the association of the particle
attribute with the appropriate mesh variable by including the following
line in the <code class="docutils literal notranslate"><span class="pre">Config</span></code> file:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">PARTICLEMAP</span> <span class="pre">TO</span></code> <em>property-name</em> <code class="docutils literal notranslate"><span class="pre">FROM</span> <span class="pre">VARIABLE</span></code> <em>variable-name</em></p>
</div></blockquote>
<p>These particle attributes are carried along in the simulation and output
in the checkpoint files. At runtime, the user can specify the attributes
to output through runtime parameters <code class="docutils literal notranslate"><span class="pre">Particles/particle_attribute_1</span></code>,
<code class="docutils literal notranslate"><span class="pre">Particles/particle_attribute_2</span></code>, etc. These specified attributes are
collected in an array by the <code class="docutils literal notranslate"><span class="pre">Particles/Particles_init</span></code> routine. This
array in turn is used by <code class="docutils literal notranslate"><span class="pre">Particles/Particles_updateAttributes</span></code> to
calculate the values of the specified attributes from the corresponding
mesh quantities before they are output.</p>
</section>
<section id="particle-i-o">
<span id="sec-particles-io"></span><h3>Particle I/O<a class="headerlink" href="#particle-i-o" title="Permalink to this headline"></a></h3>
<p>Particle data are written to and read from checkpoint files by the I/O
modules (). For more information on the format of particle data written
to output files, see and .</p>
<p>Particle data can also be written out to the <code class="docutils literal notranslate"><span class="pre">flash.dat</span></code> file. The
user should include a local copy of <code class="docutils literal notranslate"><span class="pre">IO/IO_writeIntegralQuantities</span></code> in
their Simulation directory. The <code class="docutils literal notranslate"><span class="pre">Orbit</span></code> test problem supplies an
example <code class="docutils literal notranslate"><span class="pre">IO_writeIntegralQuantities</span></code> routine that is useful for
writing individual particle trajectories to disk at every timestep.</p>
<p>There is also a utility routine <code class="docutils literal notranslate"><span class="pre">Particles/Particles_dump</span></code> which can
be used to dump particle output to a plain text file. An example of
usage can be found in <code class="docutils literal notranslate"><span class="pre">Particles/Particles_unitTest</span></code>. Output from this
routine can be read using the fidlr routine <code class="docutils literal notranslate"><span class="pre">particles_dump.pro</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Even though it is possible to do so, see
<code class="docutils literal notranslate"><span class="pre">Particles/Particles_computeDt</span></code>, one does not in general wish to
let particles integration dictate the time step of the simulation.</p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>They can be considered “predicted” positions and velocities.</p>
</dd>
</dl>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Gravity.html" class="btn btn-neutral float-left" title="Gravity Unit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="monitor.html" class="btn btn-neutral float-right" title="Monitor Units" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Flash-X Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>