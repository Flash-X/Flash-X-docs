<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FLASH-X: source/Grid/Grid_fillGuardCells.F90 File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../flash-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FLASH-X
   </div>
   <div id="projectbrief">Doxygen Generated Documentation From Interface Source Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="../../dir_f636fe1aaafd6114c78ff18cf7dc516e.html">Grid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle"><div class="title">Grid_fillGuardCells.F90 File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="../../dd/d3d/Grid__fillGuardCells_8F90_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ac9f8c84d3b6d448b9464bf61ae02adf8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d3d/Grid__fillGuardCells_8F90.html#ac9f8c84d3b6d448b9464bf61ae02adf8">Grid_fillGuardCells</a> (gridDataStruct, idir, minLayers, eosMode, doEos, maskSize, mask, makeMaskConsistent, doLogMask, selectBlockType, unitReadsMeshDataOnly)</td></tr>
<tr class="separator:ac9f8c84d3b6d448b9464bf61ae02adf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ac9f8c84d3b6d448b9464bf61ae02adf8" name="ac9f8c84d3b6d448b9464bf61ae02adf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f8c84d3b6d448b9464bf61ae02adf8">&#9670;&nbsp;</a></span>Grid_fillGuardCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine Grid_fillGuardCells </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>gridDataStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>idir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>minLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>eosMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical&#160;</td>
          <td class="paramname"><em>doEos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>maskSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension(:), optional&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical&#160;</td>
          <td class="paramname"><em>makeMaskConsistent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical&#160;</td>
          <td class="paramname"><em>doLogMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>selectBlockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical&#160;</td>
          <td class="paramname"><em>unitReadsMeshDataOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This routine fills the guardcells of the specified data structure of each block present in the mesh. If the adjacent blocks are at the same level of refinement, then the values are copied from the appropriate internal cells of the neighboring block. If the blocks are at different levels of refinement, then in addition to copying, there will be restriction or prolongation.</p>
<p >The optional arguments related to the Eos calls are provided because if a solver relies on a call to Eos to establish thermodynamic equilibrium in various variables, then either the solver can call Eos explicitly itself, or more conveniently, it can instruct the GC-fill routine to do it. This feature is especially useful when mesh quantities are used to derive, for example, tracer particle attributes. If the user opts to enable doEos, they will not have to determine whether or where an Eos call is needed, the code will do it for them. Note that Eos calls via Grid_fillGuardCells will only be applied to guard cells, and potentially only to guard cell regions where the data in those guard cells may be the result of either interpolation or cell averaging because a block boundary coincides with or touches a fine/coarse boundary.</p>
<p >For performance reasons, users may choose to use masking in filling the guardcells, which is a feature fully supported only with Paramesh4. They can do so by using the optional arguments mask, maskSize, and makeMaskConsistent. However, users should exercise extreme caution in using masking. Please see the NOTES section for potential side effects. If masking is present, and both makeMaskConsistent and doEos are true, the Eos calculation is applied only if at least one of the variables selected in the mask is potentially an output of the Eos calculation. A local routine gr_makeMaskConsistent handles this processing.</p>
<p >The argument "gridDataStruct" can take one of several valid values to determine a specific grid data structure (or combination of data structures) on which to apply the guardcell fill operation. The currently available options are listed with the arguments. Most calls in a typical Flash-X application will use CENTER as the option, since it most common to use cell-centered grid data and fill guardcells for all such variables. When using AMR with Paramesh4, the subroutine Grid_markRefineDerefine may use an additional cell-centered data structure provided by Paramesh (by default with space for only a single variable) represented by the option "WORK". More specialized applications may want to use other options. The user can also choose to fill guard cells either in a single direction, or all of them. For the Flash-X solvers supplied as of early 2022, guard cell are filled in all directions.</p>
<p >gridDataStruct - integer constant, defined in "constants.h", indicating for which grid data structures the guard cells need to be filled.</p>
<p >Paramesh has 5 data structures for grid variables, the first four include all physical variables defined on the mesh. The fifth one includes by default a single variable.</p>
<p >unk cell centered, facex,facey,facez face centered along i,j,k direction, respectively, work cell centered, single variable.</p>
<p >valid values of gridDataStruct are CENTER unk only WORK work FACEX facex FACEY facey FACEZ facez FACES facex,facey, and facez CENTER_FACES unk,facex,facey,facez</p>
<p >idir - direction of guardcell fill. User can specify ALLDIR for all (x,y,z) directions, or if, for example, the algorithm only does one directional sweep at a time, then time can be saved by filling only the guardcell direction that is needed. A user would pass in the constants IAXIS, JAXIS, or KAXIS defined in constants.h to fill guardcells in only one direction. All layers of guardcells in the given direction(s) are filled if one of IAXIS, JAXIS, or KAXIS is specified, or if ALLDIR is specified and minLayers (see below) is not present.</p>
<p >minLayers - minimum number of guardcell layers requested for all directions. The caller requests at least this many layers of guardcells to be filled. If idir is given as one of IAXIS, JAXIS, or KAXIS, this applies to any directions NOT selected by idir. On the other hand, if idir is given as ALLDIR, then minLayers appliers to all directions equally. If not specified, the default is 0 if idir is given as IAXIS, JAXIS, or KAXIS, meaning no guardcells need to be filled in for the directions perpendicular to what idir selects; the default is NGUARD, the full number of available guardcells, if idir is ALLDIR. Note that the caller can specify, using minLayers, how many layers it needs filled, but the implementation may do more and actually fill all or some additional layers. The caller must therefore not rely on some guardcells remaining unchanged.</p>
<p >This argument is meaningful with AMR Grid implementations only, and for the most part ignored by the Amrex Grid implementation (but don't count on it).</p>
<p >eosMode - the EOS mode being used by the solver that is calling the routine. Some of the valid values are : MODE_DENS_EI density and energy input, pressure and temp output MODE_DENS_PRES density/pressure input, temperature/energy output MODE_DENS_TEMP density/temperature input, pressure/energy output Other values may be supported by specific Eos implementations. When this optional argument is not present in a call, the behavior is the same as when the default Eos mode that is being used by the Grid unit is specified; the latter will usually be determined by a runtime parameter such as eosModeInit or eosMode.</p>
<p >doEos - a logical variable indicating if the calling routine wants the GC-fill routine to also make sure that Eos is applied to achieve thermodynamically consistent values of all variables.</p>
<p >The mask-related arguments are useful only with PARAMESH4. They have no meaning in UG. The Amrex Grid currently provides a partial !DEV: implementation with known failures.</p>
<p >maskSize - size of the part of the mask array to be used. Should normally be the same as the actual size of the mask array.</p>
<p >mask - It is a one-dimensional logical array with indices corresponding to variables in the grid data structures. If a variable should have its guardcells filled, the corresponding element in "mask" is true, otherwise it is false. The mask is always ignored if the runtime parameter enableMaskedGCFill is set .FALSE.</p>
<p >makeMaskConsistent - If true then when a mask is applied, the implementation of Grid_fillGuardCells makes sure that in addition to all the variables that are explicitly selected by the mask, all other variables (of the same grid data structure selected by gridDataStruct) on which those variables depend for proper GC-fill operation are also included in the set of variables that are communicated and updated in guard cells. (See NOTES section for an example regarding the dependence of conserved variables on the density variable.) the the doEos argument is also present and true, then the implementation of Grid_fillGuardCells also determines whether there is a need to apply the Eos, and the Eos calculation may be skipped if not.</p>
<p >doLogMask - If present and true when a mask is applied, stamp some information about masking (and whether Eos is or would be called) to the Logfile. Ignored in implementations that do not support variable masking.</p>
<p >selectBlockType - selects the blocks whose guard cells must be filled by block type.</p>
<p >This argument is ignored in UG Implementations.</p>
<p >For PARAMESH Grid implementations, recognized values are :</p>
<p >ALL_BLKS all local blocks on a processor. This is not valid in all PARAMESH versions.</p>
<p >ACTIVE_BLKS all currently active blocks, in the PARAMESH context this means parent and leaf blocks, that is, blocks whose node type is 1 or 2, but not blocks of node type 3 (ANCESTOR).</p>
<p >LEAF only LEAF blocks, i.e., blocks whose PARAMESH node type is 1</p>
<p >These constants are defined in constants.h</p>
<p >When selectBlockType is not present, the default behavior with a Paramesh4 Grid is essentially as described for ACTIVE_BLKS. However, note that there may be some blocks of PARENT type that have some child blocks that are NOT of LEAF type (but are themselves of PARENT type). Such PARENT blocks may not get fully updated in regions that are not covered by LEAF blocks.</p>
<p >Note that if advance_all_levels is set (in a PARAMESH version that implements this global flag), guard cells in all levels of blocks are filled anyway.</p>
<p >Note that the caller can specify, using selectBlockType, which blocks it needs filled, but the implementation may do more and actually fill guard cells in additional blocks. The caller must therefore not rely on guardcells in other blocks remaining unchanged.</p>
<p >unitReadsMeshDataOnly - specifies that the unit calling Grid_fillGuardCells will not update any internal grid data after the call; or, if it does, it will notify the Grid unit of it by calling Grid_notifySolnDataUpdate later. This protocol allows the NEXT call of Grid_fillGuardCells to skip the actual communication when it detects that the guard cells already contain up to date data.</p>
<p >EXAMPLE</p>
<p >#include "Simulation.h" #include "constants.h"</p>
<p >call Grid_fillGuardCells( CENTER, IAXIS)</p>
<p >This call will fill all guardcells for all cell-centered variables in the x direction.</p>
<p >EXAMPLE 2</p>
<p >#include "Simulation.h" #include "constants.h"</p>
<p >call Grid_fillGuardCells( WORK, ALLDIR)</p>
<p >This call fills guardcells along all directions. The operation is applied to the WORK data structure available in Paramesh only.</p>
<p >SIDE EFFECTS</p>
<p >After this function returns, all parents of leaf blocks will have current and valid solution data (at least for the variables determined by the gridDataStruct and mask dummy arguments). This is because amr_guardcell calls amr_restrict internally. If selectBlockType is used, even more parents of blocks of interest may get updated by restriction.</p>
<p >NOTES</p>
<p >In the default mode, this routine fills guardcells of all the variables in the specified data structure. However, if masking is used it is possible to fill guardcells of only selected variables. The users must exercise a great deal of caution in using masking in the guardcell filling, since masking out some variables may have unintended consequences. For example, if any conserved variable is set to true in the mask, density must be true, otherwise the interpolated values of the the conserved variable at fine-coarse boundaries will be wrong. It is highly recommended that the argument makeMaskConsistent be set to true when using masking, since that provides error checking for the variable sets included in the released solvers. However, these checks may not be enough for new solvers introduced by the users.</p>
<p >This function, or one of the lower-level functions invoked by it, MUST be called (with updated solution data) before child blocks may be removed in the course of derefinement! See side effects, above, for the reason. </p>

<p class="definition">Definition at line <a class="el" href="../../dd/d3d/Grid__fillGuardCells_8F90_source.html#l00265">265</a> of file <a class="el" href="../../dd/d3d/Grid__fillGuardCells_8F90_source.html">Grid_fillGuardCells.F90</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 4 2022 17:05:05 for FLASH-X by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
