.. include:: defs.h

.. _`Chp:CodingStandards`:

Coding Standards
============

A |flashx| unit is expected to be fully encapsulated, with all of its
data being private to it. The only global data accessible to a unit is
in the form of included *foo.h*  files, two of which are available to
every unit and every application instance. These are *Simulation.h*,
which is generated by the *setup* tool and *constants.h* which contains
all the global constants in the code. Of these *Simulation.h* does not
exist in the source tree, whereas *constanst.h* lives in the
Simulation unit. Each unit is required to have a file
*Unitname_data.F90* that declares all the data that needs to be
available on the local memory of the device where the computation is
being done. The declared data should be clustered into five
categories:

device resident data -- This is the data that is assumed to be
available on demand while computing. If the computation is offloaded
to a device, this data is sent over once at the begining and remains
on the device

device resident space allocation -- This indicates needed scratch
space to be used during computation. A good practice is to allocate
before beginning the computation and deallocate once the computation
is done.

sent not returned -- This is the data that gets updated on the host
and needs to be sent over to the device at every iteration of the
computation. But once used it does not need to be updated, and
therefore returned.

sent and returned -- This is the data that needs to be returned to the
host after computation is done.

returned only -- This is the data that is generated during computation
and needs to be returned to the host, but there is no corresponding
sending to the device.

Note that the data could be in the form of scalars, derived types, or
any other kind of data structures that are compatible with the target
devices.

If a unit intends to be compatible with offloading options then it
must not have any scratch space allocation interspersed with the
computation. Need for scratch space must either be registered with the
framework through SCRATCH keyword in Config file, or the data
structure should be declared as allocatable in the *Unitname_data.F90*
file with appropriate comments as described above.

.. _`Sec:UnitStructure`:

Structure of a Unit
----------------

Each unit has its own top level directory *Unitname* where
capitalization of the first letter indicates that the directory name
is a namespace. A unit can have subunits that show up as
subdirectories named as *UnitnameSubunitname*. Each unit has at least
one subunit which is named *UnitnameMain*. Except *UnitnameMain*, each
subunit must be encapsulated in its own right such that an application
instance can opt to exclude it if it wants to. Each unit publishes its
API through which other units can interact with it. API can be
subdivided among subunits such that the union of all API functions is
the unit API, but the intersection set of API functions implemented by
different subunits is NULL. Thus every API function is implemented by
exactly one subunit. Within the subunit any API function can have
multiple alternative implementations. Alternative implementations
reside under different subdirectories of the subunit. This
division into alternative implementations can be applied to arbitrary
depth in the directory structure, the only constraint is that when a directory
is included in the application every file (not subdirectories) in that
directory is included.  The figure below illustrates the unit
structure with the example of **Particles** unit. This unit has three
subunits, each subunit supports two alternative implementations of the
full subunit. The **MeshOwned** implementation assumes that the data
structure is owned by the mesh, while the **ParticlesOwned**
implementation assumes that the data structure is owned by the
Particles unit. Currently *MeshOwned* implementation works with
*AMReX* while *ParticlesOwned* implementation works with
*Paramesh*. In future *ParticlesOwned* method will also be compatible
with *AMReX*. Here time integration of particles is implemented in
*ParticlesMain*, with three different implementations for
*ParticlesOwned* version. Note that **passive** is an organizational
directory here because **active** particles will be brought over from
|flash| in future. Different time integration schemes relevant to
active particles will be clustered under the corresponding
organizational directory. The figure is does not show all the
directories present in the unit for clarity of presentation.

.. container:: center

   .. figure:: unitexample.png
      :alt: unitE
      :name: Fig:unit
      :width: 5in

      Organization of Particles unit as an example of unit structure
      with subunits.


Generally, the alternative implementations are
mutually exclusive, however, in certain circumstances more than one
may need to be included. For example if work is to be divided between
CPU and GPU from the same unit, both variants will need to be
included. The mechanism described in **Architecture** chapter explains how
this is done.

Placement of functions in the directories affects how inheritance
works. A common rule of thumb is, if there are multiple alternative
implementations beneath a directory *foo* with some common
functions then those common functions should be placed in *foo*. For
example in the *EOS* unit, the *Helmholtz* implementation has two
variants, *Ye* and *SpeciesBased*. The files that contain common
implementations are kept in *Helmholtz* directory, while files that
have code unique to each variant reside in the respective
subdirectories. Following the inheritance rules implemented by the
*Setup* tool, all files in *Helmholtz* will be inherited by, and
therefore included with whichever variant is included.  

.. _`Sec:API`:

 Unit API and Local API
------------------



.. _`Sec:CodeDuplication`:

Avoiding Code Duplication
----------------------


.. _`Sec:Libraries`:

Internal Vs External Libraries
-----------------------








