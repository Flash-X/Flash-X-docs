.. include:: defs.h

.. _`Chp:CodingStandards`:

Coding Standards
============

A |flashx| unit is expected to be fully encapsulated, with all of its
data being private to it. The only global data accessible to a unit is
in the form of included *foo.h*  files, two of which are available to
every unit and every application instance. These are *Simulation.h*,
which is generated by the *setup* tool and *constants.h* which contains
all the global constants in the code. Of these *Simulation.h* does not
exist in the source tree, whereas *constanst.h* lives in the
Simulation unit. Each unit is required to have a file
*Unitname_data.F90* that declares all the data that needs to be
available on the local memory of the device where the computation is
being done. The declared data should be clustered into five
categories:

device resident data -- This is the data that is assumed to be
available on demand while computing. If the computation is offloaded
to a device, this data is sent over once at the begining and remains
on the device

device resident space allocation -- This indicates needed scratch
space to be used during computation. A good practice is to allocate
before beginning the computation and deallocate once the computation
is done.

sent not returned -- This is the data that gets updated on the host
and needs to be sent over to the device at every iteration of the
computation. But once used it does not need to be updated, and
therefore returned.

sent and returned -- This is the data that needs to be returned to the
host after computation is done.

returned only -- This is the data that is generated during computation
and needs to be returned to the host, but there is no corresponding
sending to the device.

Note that the data could be in the form of scalars, derived types, or
any other kind of data structures that are compatible with the target
devices.

If a unit intends to be compatible with offloading options then it
must not have any scratch space allocation interspersed with the
computation. Need for scratch space must either be registered with the
framework through SCRATCH keyword in Config file, or the data
structure should be declared as allocatable in the *Unitname_data.F90*
file with appropriate comments as described above.

.. _`Sec:UnitStructure`:

Structure of a Unit
----------------

Each unit has its own top level directory *Unitname* where
capitalization of the first letter indicates that the directory name
is a namespace. A unit can have subunits that show up as
subdirectories named as *UnitnameSubunitname*. Each unit has at least
one subunit which is named *UnitnameMain*. Except *UnitnameMain*, each
subunit must be encapsulated in its own right such that an application
instance can opt to exclude it if it wants to. Each unit publishes its
API through which other units can interact with it. API can be
subdivided among subunits such that the union of all API functions is
the unit API, but the intersection set of API functions implemented by
different subunits is NULL. Thus every API function is implemented by
exactly one subunit. Within the subunit any API function can have
multiple alternative implementations. Alternative implementations
reside under different subdirectories of the subunit. This
division into alternative implementations can be applied to arbitrary
depth in the directory structure, the only constraint is that when a directory
is included in the application every file (not subdirectories) in that
directory is included. Generally, the alternative implementations are
mutually exclusive, however, in certain circumstances more than one
may need to be included. For example if work is to be divided between
CPU and GPU from the same unit, both variants will need to be
included. The mechanism described in architecture chapter explains how
this is done.



.. _`Sec:API`:

 Unit API and Local API
------------------


.. _`Sec:CodeDuplication`:

Avoiding Code Duplication
----------------------


.. _`Sec:Libraries`:

Internal Vs External Libraries
-----------------------








