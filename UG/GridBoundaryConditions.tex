%------------------------------------------------------------------------
% Boundary conditions
%------------------------------------------------------------------------
\section{Boundary Conditions}
\label{Sec:BndryCond}

 Much of the \flashx code within the \unit{Grid} unit that deals with
implementing boundary conditions has been organized into a separate
\subunit, \unit{GridBoundaryConditions}.
Note that the following aspects are still handled elsewhere:
\begin{itemize}
\item Recognition of bounday condition  names as strings (in runtime parameters) 
and constants (in the source code); these are defined in 
\api{RuntimeParameters/RuntimeParameters_mapStrToInt} and in \code{constants.h},
respectively.
\item Handling of periodic boundary conditions; this is done within the underlying
\unit{GridMain} implementation. When using \Paramesh,
the subroutine \code{gr\_createDomain} is responsible for setting the
neighbors of top-level blocks (to either other top-level
blocks or to external boundary conditions) at initialization,
after \rpi{Grid/Nblockx} $\times$ \rpi{Grid/Nblocky} $\times$ \rpi{Grid/Nblockz}
root blocks have been created.
periodic (wrap-around) boundary conditions are initially configured in
this routine as well. If periodic boundary conditions are set in the
$x$-direction, for instance, the first blocks in the $x$-direction are
set to have as their left-most neighbor the blocks that are last in
the $x$-direction, and {\it vice versa}. Thus, when the guard cell
filling is performed, the periodic boundary conditions are
automatically maintained.
\item Handling of user-defined boundary conditions; this should be implemented
by code under the 
\newline
\unit{Simulation} directory.
\item
Low-level implementation and interfacing, such as are part of the \Paramesh code.
\item
Behavior of particles at a domain boundary. This is based on the boundary types
described below, but their handling is implemented
in \unit{GridParticles}.
\end{itemize}


Although the \unit{GridBoundaryConditions} \subunit is included in a
setup by default, it can be excluded (if no \code{Config} file
``\code{REQUIRES}'' it) by specifying
\code{-without-unit=Grid/GridBoundaryConditions}. This will generally
only make sense if all domain boundaries are to be treated as
periodic.  (All relevant runtime parameters
\rpi{Grid/xl_boundary_type} \etc need to be set to \code{"periodic"} in that
case.)

\subsection{Boundary Condition Types}
Boundary conditions %\index{boundary conditions}%\index{grid!boundary|see{boundary conditions}}
are determined by the physical problem.
%They are implemented
%by setting appropriate runtime parameters in flash.par, and filling the
%grid in \api{Simulation/Simulation_initBlock}.
Within Flash-X, the parallel structure of blocks means that each
processor works independently. If a block is on a physical boundary,
the  guard cells are filled by calculation
since there are no neighboring blocks from which to copy
values. Boundaries are selected by setting runtime parameters such as
\rpi{Grid/xl_boundary_type} (for the `left' $X$--boundary) to
one of the supported boundary types (\tblref{Tab:Boundaries}) in
\code{flash.par}. Even though the runtime parameters for specifying
boundary condition types are strings, the \unit{Grid} unit understands them as
defined integer constants defined in the file
\code{constants.h}, which contains all global constants for
the code. The translation from the string specified in
``flash.par'' to the constant understood by the \unit{Grid} unit is done by the
%% function \api{Simulation/Simulation_mapStrToInt}, which is generated by \code{setup}. %% -not so!
routine \api{RuntimeParameters/RuntimeParameters_mapStrToInt}.

\begin{table}[ht]
\label{Tab:Boundaries}
\begin{center}
\begin{tabular}{ll}
{\bf {\it ab}\_boundary\_type} & {\bf Description}\medskip\\
\hline
\code{periodic}     & Periodic (`wrap-around') \medskip\\
\code{reflect},\code{reflecting} & 
\begin{minipage}{0.6\textwidth}
Non-penetrating boundaries; plane symmetry,
the normal vector components change sign 
\end{minipage}
\medskip\\
\code{outflow}      & Zero-gradient boundary conditions; allows shocks
                     to leave the domain \medskip\\
\hline
\code{diode}        & 
\begin{minipage}{0.6\textwidth}
like outflow, but fluid velocities are never allowed to
                      let matter flow into the domain: normal velocity components are
		      forced to zero in guard cells if necessary
\end{minipage}
\medskip\\
\hline
\code{axisymmetric} & 
\begin{minipage}{0.6\textwidth}
like \code{reflect}, but both normal and toroidal vector components change sign.
Typically used with cylindrical geometry (R-Z) for the Z symmetry axis.
\end{minipage}
\medskip\\
\code{eqtsymmetric} & 
\begin{minipage}{0.6\textwidth}
like reflect for velocities but the magnetic field components, poloidal and toroidal,
change sign. The sign of the normal magnetic field component remains the same.
Typically used with cylindrical geometry (R-Z) for the R axis to emulate equatorial
symmetry.
\end{minipage}
\medskip\\
\hline
\code{hydrostatic-f2}  & Hydrostatic boundary handling as in \flashx. See remark in text. \medskip\\
\hline
\begin{minipage}{0.25\textwidth}
\code{hydrostatic-f2+nvrefl},
\code{hydrostatic-f2+nvout},
\code{hydrostatic-f2+nvdiode}
\end{minipage}
&
\begin{minipage}{0.6\textwidth}
Variants of \code{hydrostatic-f2}, where the \textbf{n}ormal \textbf{v}elocity
is handled specially in various ways, analogous to
\code{reflect}, \code{outflow}, and \code{diode} boundary conditions, respectively. See remark in text.
\end{minipage}
\medskip\\
\hline
\begin{minipage}{0.2\textwidth}
\code{user-defined}
 or \code{user}
\end{minipage}
&
\begin{minipage}{0.6\textwidth}
The user must implement the desired boundary behavior; see text.
\end{minipage}
\medskip\\
\hline
\end{tabular}
\caption{  Hydrodynamical boundary conditions supported by Flash-X. Boundary type {\it ab} may be
replaced with $a$=\{x,y,z\} for direction and $b$=\{l,r\} for left/right edge.
All boundary types listed except the last (\code{user}) have an implementation in \unit{GridBoundaryConditions}.}
\end{center}
\end{table}

To use any of the \code{hydrostatic-f2*} boundary conditions, the setup must
include \code{Grid/GridBoundary\-Conditions/\-Flash2HSE}.  This must
usually be explicitly requested, for example with a line
\begin{codeseg}
REQUIRES Grid/GridBoundaryConditions/Flash2HSE
\end{codeseg}
in the simulation directory's \code{Config} file.

% \begin{comment}
% \code{hydrostatic}  & Supports the fluid `above' against gravity \\
% \code{diode}        & like outflow, but fluid velocities are never allowed to
% The user must override the default
% \api{Grid/Grid_applyBCEdge} with an implementation
% that adds the desired boundary behavior.
% \end {comment}


Note that the \rpi{Gravity/grav_boundary_type} runtime parameter is 
used by some implementations of the \unit{Gravity} unit
to define the type of boundary for solving a self-gravity (Poisson) problem;
see \api{physics/Gravity/Gravity_init}. This runtime parameter is
separate from the {\bf {\it ab}\_boundary\_type} ones interpreted
by \unit{GridBoundaryConditions}, and its recognized values are
not the same (although there is some overlap).


\begin{table}[ht]
\begin{center}
\begin{tabular}{lll}
{\bf {\it ab}\_boundary\_type} & {\bf Constant}& {\bf Remark}\\
\hline
\code{isolated}        & --- & used by Gravity only for \rpi{Gravity/grav_boundary_type} \\
---                    & \code{DIRICHLET} & used for multigrid solver \\
---                    & \code{GRIDBC\_MG\_EXTRAPOLATE} & for use by multigrid solver\\
---                    & \code{PNEUMANN} & (for use by multigrid solver) \\
\hline
\code{hydrostatic}  & \code{HYDROSTATIC} &  Hydrostatic, other implementation than \flashx \\
\hline
\code{hydrostatic+nvrefl}& \code{HYDROSTATIC\_NVREFL} &  Hydrostatic variant, other impl.~ than \flashx \\
\code{hydrostatic+nvout}& \code{HYDROSTATIC\_NVOUT} &  Hydrostatic variant, other impl.~ than \flashx \\
\code{hydrostatic+nvdiode}& \code{HYDROSTATIC\_NVDIODE} &  Hydrostatic variant, other impl.~ than \flashx \\
\hline
\hline
\end{tabular}
\caption{Additional boundary condition types recognized by Flash-X. Boundary type {\it ab} may be
replaced with a=\{x,y,z\} for direction and b=\{l,r\} for left/right edge.
These boundary types are either reserved for implementation by users and/or future
Flash-X versions for a 
specific purpose (as indicate by the remarks), or are for special uses
within the \unit{Grid} unit.}
\label{Tab:RecognizedBoundaries}
\end{center}
\end{table}




\subsection{Boundary Conditions at Obstacles}

The initial coarse grid of root blocks can be modified by removing certain blocks.
This is done by providing a non-trivial implementation of
\api{Simulation/Simulation_defineDomain}. Effectively this creates
additional domain boundaries at the interface between blocks removed
and regions still included. All boundary conditions other than
\code{periodic} are possible at these additional boundaries, and
are handled there in the same way as on external domain boundaries.
This feature is only available with \Paramesh.
See the documentation and example in \api{Simulation/Simulation_defineDomain}
for more details and some caveats.

\subsection{Implementing Boundary Conditions}

Users may need to implement boundary conditions
beyond those provided with \flashx, and the \unit{Grid\-Boundary\-Conditions} \subunit
provides several ways to achieve this.
Users can provide an implementation for the \code{user} boundary type;
or can provide or override an implementation for one of the other
recognized types.

The simple boundary condition types \code{reflect},
\code{outflow}, \code{diode} are implemented in the
\newline
\api{Grid/Grid_bcApply\-To\-Region}\code{.F90} file in
\code{Grid/GridBoundaryConditions}.  A users can
add or modify the handling of some boundary condition
types in a version of this file in the simulation directory,
which overrides the regular version.  There is, however, also
the interface \api{Grid/Grid_bcApplyToRegionSpecialized}
which by default is only provided as a stub and is
explicitly intended to be implemented by users.
\newline
A \api{Grid/Grid_bcApplyToRegionSpecialized} implementation
gets called before \api{Grid/Grid_bcApplyToRegion}
and can decide to either handle a specific combination
of boundary condition type, direction, grid data structure, \etc,
or leave it to \api{Grid/Grid_bcApplyToRegion}.
These calls operate on a region of one block's cells at a time.
Flash-X will pass additional information beyond that needed
for handling simple boundary conditions to 
\api{Grid/Grid_bcApplyToRegionSpecialized}, in particular
a block handle through which an implementation can
retrieve coordinate information and access
other information associated with a block and its cells.

The \unit{GridBoundaryConditions} \subunit also provides
a simpler kind of interface if one includes 
\code{Grid/\-GridBoundaryConditions/OneRow} in the setup.
When using this style of interface, users can implement
guard cell filling one row at a time. Flash-X passes
to the implementation one row of cells at a time,
some of which are interior cells while the others
represent guard cells outside the boundary that are
to be modified in the call.
A row here means a contiguous set of cells along a line perpendicular
to the boundary surface.
There are two versions of this interface:
\api{Grid/Grid_applyBCEdge} is given only one fluid
variable at a time, but can also handle data structures
other than \code{unk}; whereas \api{Grid/Grid_applyBCEdgeAllUnkVars}
handles all variables of \code{unk} along a row in one call.
Cell coordinate information is included in the call arguments.
Flash-X invokes these functions through an implementation
of \api{Grid/Grid_bcApplyToRegionSpecialized} in
\code{Grid/GridBoundaryConditions/OneRow} which acts as a wrapper.
\code{GridBoundaryConditions/OneRow} also provides a default
implementation of \api{Grid/Grid_applyBCEdge} (which implements
the simple boundary conditions) and \api{Grid/Grid_applyBCEdgeAllUnkVars}
(which calls \code{Grid\_applyBCEdge}) each.
Another implementation of \api{Grid/Grid_applyBCEdgeAllUnkVars}
can be found in
\code{GridBoundaryConditions/OneRow/Flash2HSE},
this one calls \code{Grid\_applyBCEdge} or, for \flashx-type
hydrostatic boundaries, the code for handling them.
These can be used as templates for overriding implementations
under \code{Simulation}.
It is not recommended to try to mix both \code{Grid\_bcApplyToRegion*}-style
and \code{Grid\_applyBCEdge*}-style overriding implementations in
a simulation directory, since this could become confusing.


Note that in all of these cases, \ie, whether boundary guard
cell filling for a boundary type is implemented in
\api{Grid/Grid_bcApplyToRegion},
\api{Grid/Grid_bcApplyToRegionSpecialized},
\api{Grid/Grid_applyBCEdge}, or
\newline
\api{Grid/Grid_applyBCEdge\-AllUnkVars}, the implementation
does not fill guard cells in permanent data storage (the
\code{unk} array and similar data structures) directly,
but operates on buffers. \flashx fills some parts of the buffers
with current values for interior cells before the
call, and copies updated guardcell data from some (other) parts
of the buffers back into \code{unk} (or similar) storage
after the handling routine returns.

All calls to handlers for boundary conditions are for one face in a given
dimension at a time. Thus for each of the
\code{IAXIS}, \code{JAXIS}, and \code{KAXIS} dimensions there can be up to
two series of calls, once for
the left, \ie, ``\code{LOW},'' and once for the right, \ie,
``\code{HIGH},'' face.  \Paramesh4 makes additional calls
for filling guard cells in edge and corner regions of blocks,
these calls result in additional \code{Grid\_bcApplyToRegion*}\ invocations
for those cells that lie in diagonal directions from the block interior.

The boundary condition handling interfaces described so far can
be implemented (and will be used!) independent of the \unit{Grid}
implementation chosen. At a lower level, the various implementations
of \unit{GridMain} have different ways of requesting that
boundary guard cells be filled. The \unit{GridBoundaryConditions} \subunit
collaborates with \unit{GridMain} implementations to provide to user code
uniform interfaces that are agnostic of lower-level details.
However, it is also possible --- but not recommended --- for users to
replace a routine that is located
deeper in the \unit{Grid} unit. For \Paramesh4, the most relevant
routine is \code{amr\_1blk\_bcset.F90}, for \Paramesh2 it is
\code{tot\_bnd.F90}, and for uniform grid \code{UG} it is
\code{gr\_bcApplyToAllBlks.F90}.

\subsubsection{Additional Concerns with \Paramesh4}
Boundary condition handling has become significantly more complex in \flashx.
In part this is so because \Paramesh4 imposes requirements on
guard cell filling code that do not exist in the other \code{GridMain}
implementations:
\begin{enumerate}
\item In other \code{Grid} implementations, filling of domain boundary guard cells
is under control of the ``user'' (in this context, the user of the grid implementation,
\ie, Flash-X): These cells can be filled for all blocks at a time that is predictable to the user
code, as a standard part of handling \api{Grid/Grid_fillGuardCells}, only.
With \Paramesh4, the user-provided \code{amr\_1blk\_bcset} routine can be called
from within the depths of \Paramesh on individual blocks (and cell regions, see below)
during guard cell filling and at other times when the user has called a \Paramesh
routine. It is not easy to predict when and in which sequence this will happen.
\item \Paramesh4 does not want all boundary guard cells filled in one call,
but requests individual regions in various calls.
\item \Paramesh4 does not let the user routine \code{amr\_1blk\_bcset} operate on 
permanent storage (\code{unk} \etc) directly, but on (regions of) one-block
buffers.
\item \Paramesh4 occasionally invokes \code{amr\_1blk\_bcset} to operate on 
regions of a block that belongs to a remote processor (and for which
data has been cached locally). Such block data is not associated with
a valid local \code{blockID}, making it more complicated for user
code to retrieve metadata that may be needed to implement the
desired boundary handling.
\end{enumerate}

Some consequences of this for \flashx users:
\begin{itemize}
\item
User code that implements boundary conditions for the grid inherits
the requirement that it must be ready to be called at various times
(when certain \unit{Grid} routines are called).
\item
User code that implements boundary conditions for the grid inherits
the requirement that it must operate on a region of the cells of
a block, where the region is specified by the caller.
\item
Such user code must not assume that it operates on permanent data (in \code{unk} \etc).
Rather, it must be prepared to fill guardcells for a block-shaped buffer
that may or may not end up being copied back to permanent storage.

User code also is not allowed to make certain \Paramesh4 calls while
a call to  \code{amr\_1blk\_bcset} is active, namely those that
would modify the same one-block buffers that the current call
is working on.
\item
The user code must not assume that the block data it is acting on belongs to
a local block. The data may not have a valid \code{blockID}.
The code will be passed a ``block hande'' which can be used
in some ways, but not all, like a valid \code{blockID}.
%This last point may be most onerous.
\end{itemize}

