\chapter{Particles Unit}
\label{Chp:Particles}

The support for particles in \flashx will eventually be in two
flavors, \emph{active} and \emph{passive}. This version only supports
passive particles. Passive particles acquire their kinematic information (velocities)
directly from the mesh. They are meant to be used as passive flow tracers and
do not make sense outside of a hydrodynamical context. The governing
equation for the $i$th passive particle is particularly simple and
requires only the time integration of interpolated mesh
velocities. \begin{equation}\label{Eqn:particle_motion_velocity}
{d{\bf x}_i\over dt}    =  {\bf v}_i 
\end{equation}
Active particles experience forces and may themselves contribute to
the problem dynamics (\eg, through long-range forces or through
collisions). They may additionally have their own motion independent
of the grid, so an additional motion equation of 
    \begin{equation}
    \label{Eq:particle_motion_acceleration}
      {\bf v}_i^{n+1} = {\bf v}_i^n + {\bf a}_i^n\Delta t^n ~.
    \end{equation}
may come into play. Here ${\bf a}_i$ is the particle
acceleration. Solving for the motion of active particles is also
referred to as solving the $N$-body problem. The equations of motion
for the $i$th active particle include the equation
\eqref{Eqn:particle_motion_velocity} and another describing the
effects of forces. 

\begin{equation} 
\label{Eqn:particle_motion_forces}
m_i{d{\bf v}_i\over dt} =  {\bf F}_{{\rm lr,}i} + {\bf F}_{{\rm sr,}i}\ ,
\end{equation}
Here, ${\bf F}_{{\rm lr,}i}$ represents the sum of all long-range forces
(coupling all particles, except possibly those handled by the short-range term)
acting on the $i$th particle and ${\bf F}_{{\rm sr,}i}$ represents the
sum of all short-range forces (coupling only neighboring particles)
acting on the particle.

For both types of particles, the primary challenge is to integrate
\eqref{Eqn:particle_motion_velocity} forward through time. Many
alternative integration methods are described in
Section~\secref{Sec:Particles Integration} below.  Additional
information about the mesh to particle mapping is described in
\secref{Sec:Particles Mapping}.  An introduction to the particle
techniques used in Flash-X is given by R.~W.~Hockney and J.~W.~Eastwood
in {\it Computer Simulation using Particles} (Taylor and Francis,
1988).



\section{Time Integration}
\label{Sec:Particles Integration}

The passive particles have many different time
integration schemes available. 
The subroutine
\api{Particles/Particles_advance} handles the 
movement of particles through space and time. 
Because \flashx will have support for including different types of both active
and passive particles in a single simulation, the implementation of
\api{Particles/Particles_advance} may call several
helper routines of the form \code{pt\_advance\metavar{METHOD}} (\eg,
\code{pt\_advanceLeapfrog}, \code{pt\_advanceEuler\_active}, \code{pt\_advanceCustom}),
each acting on an appropriate subset of existing particles.
The \metavar{METHOD} here is determined by the \code{ADVMETHOD} part of the
\code{PARTICLETYPE} \code{Config} statement (or the
\code{ADV} par of a \code{-particlemethods} \setup option) for the type of particle. 
See the \code{Particles\_advance} source code for the mapping from 
\code{ADVMETHOD} keyword to \code{pt\_advance\metavar{METHOD}} subroutine call.


\subsection{Passive Particles}
\label{Sec:Passive Partices Integration}
Passive particles may be moved using one of several different methods
available in \flashx. With the exception of \textbf{Midpoint},
they are all single-step schemes. The methods are either first-order
or second-order accurate, and all are explicit, as described below.
In all implementations,
particle velocities are obtained by mapping grid-based velocities onto
particle positions as described in \secref{Sec:Particles Mapping}.

Numerically solving Equation~\eqref{Eqn:particle_motion_velocity} for passive particles
means solving a set of simple ODE initial value problems, separately for each particle,
where the velocities ${\bf v}_i$ are given at certain discrete points in time
by the state of the hydrodynamic velocity field at those times.
The time step is thus externally given and cannot be arbitrarily chosen by
a particle motion ODE solver\footnote{Even though it is possible to do so, see \api{Particles/Particles_computeDt}, one does not in general wish to let particles integration dictate the time step of the simulation.}. Statements about the order of a method in this context should
be understood as referring to the same method if it were applied in a hypothetical
simulation where evaluations of velocities ${\bf v}_i$ could be performed at
arbitrary times (and with unlimited accuracy). Note that \flashx does not
attempt to provide a particle motion ODE solver of higher accuracy than second order,
since it makes little sense to integrate particle motion to a higher order
than the fluid dynamics that provide its inputs.

In all cases, particles are advanced in time from $t^n$ (or, in the
case of \code{Midpoint}, from $t^{n-1}$) to $t^{n+1} = t^n + \Delta
t^n$ using one of the difference equations described below. The
implementations assume that at the time when
\api{Particles/Particles_advance} is called, the fluid fields have
already been updated to $t^{n+1}$, as is the case with the
\api{Driver/Driver_evolveFlash} implementations provided with
\flashx. A specific implementation of the passive portion of
\api{Particles/Particles_advance} 
 is selected by a setup option such
as \code{-with-unit=\-Particles/\-ParticlesMain/\-passive/\-Euler}, or by
specifying something like \code{REQUIRES
Particles/\-ParticlesMain/passive/\-Euler} in a simulation's
\code{Config} file (or by listing the path in the \code{Units} file if
not using the \code{-auto} configuration option).  
Further details are given is \secref{Sec:ParticlesUsing} below.


\begin{itemize}
\item {\bf Forward Euler (\code{Particles/\-ParticlesMain/passive/\-Euler}).}
Particles are
      advanced in time from $t^n$ to $t^{n+1} = t^n + \Delta t^n$
      using the following difference equation:
      \begin{equation}
    \label{Eqn:particle_passive_euler}
      {\bf x}_i^{n+1} = {\bf x}_i^n + {\bf v}_i^n\Delta t^n \quad.
      \end{equation}
Here ${\bf v}_i^n$ is the velocity of the particle, which is obtained using particle-mesh interpolation from the grid
at $t=t^n$.

Note that this evaluation of ${\bf v}_i^n$ cannot be deferred until the time when it is
needed at $t=t^{n+1}$, since at that point the fluid variables have been updated
and the velocity fields at $t=t^n$ are not available any more. Particle velocities are therefore
interpolated from the mesh at $t=t^n$ and stored as particle attributes.
Similar concerns apply to the remaining methods but will not be explicitly mentioned
every time.



\item{\textbf{Two-Stage Runge-Kutta (\code{Particles/\-ParticlesMain/passive/\-RungeKutta}).}}
This 2-stage Runge-Kutta scheme is the preferred choice in \flashx. It is also the default which
is compiled in if particles are included in the setup but no specific \childunit is requested.
The scheme is also known as Heun's Method:
      \begin{eqnarray}
    \label{Eqn:particle_passive_rk2}
      {\bf x}_i^{n+1} &=& {\bf x}_i^n + \frac{\Delta t^n}{2} 
                     \left[ {\bf v}_i^n + {\bf v}_i^{*,n+1} \right]      \;,\\
      \hbox{where}\quad {\bf v}_i^{*,n+1} &=& {\bf v}({\bf x}_i^{*,n+1},t^{n+1})    \;,\nonumber\\
      {\bf x}_i^{*,n+1} &=& {\bf x}_i^n + \Delta t^n
                     {\bf v}_i^n       \quad.\nonumber
      \end{eqnarray}
Here ${\bf v}({\bf x},t)$ denotes evaluation (interpolation) of the fluid velocity field
at position $\bf x$ and time $t$;
      ${\bf v}_i^{*,n+1}$ and ${\bf x}_i^{*,n+1}$ are intermediate
results \footnote{They can be considered ``predicted'' positions and velocities.};
and
${\bf v}_i^n = {\bf v}({\bf x}_i^{n},t^{n})$ is the velocity of the particle, obtained using particle-mesh interpolation from the grid
at $t=t^n$ as usual.


\item{\textbf{Midpoint (\code{Particles/\-ParticlesMain/passive/\-Midpoint}).}}
This Midpoint scheme is a two-step scheme.  Here, the particles are advanced from time
 $t^{n-1}$ to $t^{n+1} = t^{n-1} + \Delta t^{n-1} + \Delta t^{n}$ by the equation
     \begin{equation}
      {\bf x}_i^{n+1} = {\bf x}_i^{n-1} + {\bf v}_i^{n}(\Delta t^{n-1} + \Delta t^{n}) \quad.
      \end{equation}
The scheme is second order if $\Delta t^n = \Delta t^{n-1}$.

To get the scheme started, an Euler step (as described for \code{passive/Euler}) is taken the first time 
\code{Particles/\-ParticlesMain/passive/\-Midpoint/\-pt_advancePassive} is called.

The \code{Midpoint} \childunit uses the following additional particle attributes:
\begin{codeseg}
PARTICLEPROP pos2PrevX REAL           # two previous x-coordinate
PARTICLEPROP pos2PrevY REAL           # two previous y-coordinate
PARTICLEPROP pos2PrevZ REAL           # two previous z-coordinate
\end{codeseg}




\item{\textbf{Estimated Midpoint with Correction (\code{Particles/\-ParticlesMain/passive/EstiMidpoint2}).}}
The scheme is second order even if $\Delta t^n = \Delta t^{n+1}$ is not assumed.
It is essentially the \code{EstiMidpoint} or ``Predictor-Corrector'' method of
previous releases, with a correction for 
non-constant time steps
by using additional evaluations (at times and positions
that are easily available, without requiring more particle attributes).

Particle advancement follows the equation
%begin{latexonly}
\catcode`\_=8\relax
%end{latexonly}
% This crap from previously in the file which was commented out
% Klaus, could you define the damn terms consistently at the TOP of the file?
\newcommand{\XP}{\textbf{xp(t+1.5*dtNew)}}
\newcommand{\VP}{\textbf{vp(t+1.5*dtNew)}}
\newcommand{\Deltat}{{\Delta t}}
\catcode`\_=8
\newcommand{\xn}{{\bf x}_i^{n}}
\newcommand{\vn}{{\bf v}_i^{n}}
\newcommand{\tn}{t^{n}}
\newcommand{\tp}{t_{*}^{n+\frac12}}
\newcommand{\tP}{t^n + \Deltatp }
\newcommand{\thalf}{t^{n+\frac12}}
\newcommand{\tH}{t^n + \frac12 \Delta t^{n} }
%\newcommand{\Deltatp}{\Delta t^{*,n-\frac12} }
\newcommand{\Deltatp}{\Delta t_{*}^{n} }
\newcommand{\DeltatP}{\frac12 \Delta t^{n-1} }
\newcommand{\Deltathalf}{\frac12 \Delta t^{n}}
\newcommand{\xh}{{\bf x}_i^{{\mathrm{E}},n+\frac12}}
\newcommand{\xp}{{\bf x}_i^{*,n+\frac12}}
\newcommand{\vp}{{\bf v}_i^{*,n+\frac12}}
% These nearly identical things were defined for this section.  Right.
\newcommand{\vcomb}{{\bf v}_i^{\mathrm{comb}}}
\newcommand{\CA}{c_1(\Deltat^{n-1},\Deltat^n)}
\newcommand{\CB}{c_2(\Deltat^{n-1},\Deltat^n)}
\newcommand{\CC}{c_3(\Deltat^{n-1},\Deltat^n)}
\newcommand{\CD}{c_4(\Deltat^{n-1},\Deltat^n)}
\newcommand{\cA}{c_1}
\newcommand{\cB}{c_2}
\newcommand{\cC}{c_3}
\newcommand{\cD}{c_4}
%\newcommand{\e}{{\mathbf{e}}_i}

\begin{equation}
\label{Eqn:EstiMidpoint2}
{\bf x}_i^{n+1} = {\bf x}_i^n +   {\Deltat}^n \, \vcomb      \;,
\end{equation}
where
\begin{equation}
\label{Eqn:pt_em2-2}
\vcomb =
\cA\,{\bf v}(\xp,t^{n})   +
\cB\,{\bf v}(\xp,t^{n+1})   +
\cC\,{\bf v}(\xn,t^{n})   +
\cD\,{\bf v}(\xn,t^{n+1})
\end{equation}
is a combination of four evaluations (two each at the previous and the current time),
\begin{equation*}
\xp = {\bf x}_i^n + \frac12 \Delta t^{n-1} {\bf v}_i^n
\end{equation*}
are estimated midpoint positions as before in the Estimated Midpoint scheme,
and the coefficients
\begin{eqnarray*}
\cA&=&\CA\;,\\
\cB&=&\CB\;,\\
\cC&=&\CC\;,\\
\cD&=&\CD
\end{eqnarray*}
are chosen dependent on the change in time step so that the method stays
second order when $\Deltat^{n-1} \neq \Deltat^n$.


Conditions for the correction can be derived as follows:
Let 
$\Deltatp=\DeltatP$  the estimated half time step
used in the scheme, let $\tp=\tP$ the estimated midpoint time,
and $\thalf=\tH$ the actual midpoint of the $[t^n,t^{n+1}]$ interval.
Also write $\xh = \xn+ \Deltathalf\vn$ for 
first-order (Euler) approximate positions
at the actual midpoint time $\thalf$,
and we continue to denote with $\xp$ the estimated positions 
reached at the estimated mipoint time $\tp$.

Assuming reasonably smooth functions ${\bf v}({\bf x},t)$,
we can then write 
 for the exact value of the velocity field at the approximate
positions
evaluated at the actual midpoint time
\begin{equation}
    \label{Eqn:vhalf_expansion}
{\bf v}(\xh,\thalf) = 
   {\bf v}(\xn,\tn) +
      {\bf v}_t(\xn,\tn)\Deltathalf +
      (\vn \cdot \frac{\partial}{\partial {\bf x}}) {\bf v}(\xn,\tn)\Deltathalf +
         O((\Deltathalf)^2)
\end{equation}
by Taylor expansion. 
It is known that the propagation scheme
$\widetilde{{\bf x}}_i^{n+1}=\xn+{\bf v}(\xh,\thalf) \Deltat$ 
using these velocities is second order
(this is known as the modified Euler method).


On the other hand, expansion of \eqref{Eqn:pt_em2-2} gives
\begin{eqnarray}
\vcomb &=& 
(\cA+\cB+\cC+\cD) {\bf v}(\xn,\tn) \nonumber\\
&& +\;
   (\cB +    \cD) {\bf v}_t(\xn,\tn) \Deltat \;+\;
  (\cA+\cB )  (\vn \cdot \frac{\partial}{\partial {\bf x}}) {\bf v}(\xn,\tn) \Deltatp  \nonumber\\
&& \quad +    \quad    \mbox{higher order terms in $\Deltat$ and $\Deltatp$.} \nonumber
\end{eqnarray}
After introducing a  time step factor $f$ defined by
$\Deltatp = f\,\Deltat^{n}$, this becomes
\begin{eqnarray}
    \label{Eqn:vcomb_expansion}
\vcomb &=& 
(\cA+\cB+\cC+\cD) {\bf v}(\xn,\tn) \\
&& +\;
   (\cB +    \cD) {\bf v}_t(\xn,\tn) \Deltat \;+\;
  (\cA+\cB )(\vn \cdot \frac{\partial}{\partial {\bf x}}) {\bf v}(\xn,\tn) \,f\,\Deltat  \nonumber\\
&& \quad  +  \; O((\Deltat)^2)\quad. \nonumber
\end{eqnarray}


One can derive conditions for second order accuracy by comparing
\eqref{Eqn:vcomb_expansion} with \eqref{Eqn:vhalf_expansion} and requiring that
\begin{equation}
\vcomb =  {\bf v}(\xh,\thalf) +  O((\Deltat)^2)\quad.
\end{equation}
It turns out that the coefficients have to satisfy three conditions
in order to eliminate from the theoretical difference between 
numerical and exact solution
all $O(\Deltat^{n-1})$ and $O(\Deltat^{n})$ error terms:
\begin{eqnarray*}
   \cA+\cB+\cC+\cD &=& 1  \quad  \mbox{(otherwise the scheme will not even be of first order)}\;,\\
      \cB   +\cD &=& \frac12 \quad  \mbox{(and thus also $\cA+\cC=\frac12$)}\;, \\ 
   \cA+\cB       &=& \frac{ \Deltat^n } { \Deltat^{n-1} } \quad.
\end{eqnarray*}
The provided implementation chooses $\cD=0$ (this can be easily changed if desired by editing in the code).
All four coefficients are then determined:
     \begin{eqnarray*}
\cA&=&\frac{ \Deltat^n } { \Deltat^{n-1} } - \frac12\;,\\
\cB&=&\frac12\;,\\
\cC&=&1 - \frac{ \Deltat^n } { \Deltat^{n-1} }\;,\\
\cD&=&0\quad.
      \end{eqnarray*}
Note that when the time step remains unchanged we have $\cA=\cB=\frac12$ and $\cC=\cD=0$,
and so \eqref{Eqn:EstiMidpoint2} simplifies significantly.
% to \eqref{Eqn:EstiMidpoint}.



An Euler step, as described for \code{passive/Euler} in \eqref{Eqn:particle_passive_euler}, 
 is taken the first time when
\code{Particles/\-ParticlesMain/passive/\-EstiMidpoint2/\-pt\_advancePassive} is called and when the
time step has changed too much. 
Since the integration scheme is tolerant of time step changes, it should
usually not be necessary to apply the second criterion; even when it is to be employed,
the criteria should be less strict than for an uncorrected \code{EstiMidpoint} scheme.
For \code{EstiMidPoint2} the timestep is considered to have changed too much
if either of the following is true:
\begin{displaymath}
     \Delta t^{n} > \Delta t^{n-1} 
\quad\mbox{and}\quad
    \left| \Delta t^{n} - \Delta t^{n-1} \right| \geq
                                                      \code{pt\_dtChangeToleranceUp} \times  \Delta t^{n-1}
\end{displaymath}
or 
\begin{displaymath}
     \Delta t^{n} < \Delta t^{n-1} 
\quad\mbox{and}\quad
    \left| \Delta t^{n} - \Delta t^{n-1} \right| \geq
                                                      \code{pt\_dtChangeToleranceDown} \times  \Delta t^{n-1},
\end{displaymath}
where \rpi{Particles/pt\_dtChangeToleranceUp} and \rpi{Particles/pt\_dtChangeToleranceDown} are runtime parameter
specific to the \code{EstiMidPoint2} \childunit.



The \code{EstiMidpoint2} \childunit uses the following additional particle attributes
for storing the values of $\xp$ and $\vp$ between the \code{Particles\_advance} calls at $t^n$
and $t^{n+1}$:
\begin{codeseg}
PARTICLEPROP velPredX REAL
PARTICLEPROP velPredY REAL
PARTICLEPROP velPredZ REAL
PARTICLEPROP posPredX REAL
PARTICLEPROP posPredY REAL
PARTICLEPROP posPredZ REAL
\end{codeseg}

\end{itemize}


The time integration of passive particles is tested in the \code{ParticlesAdvance} unit test,
which can be used to examine the convergence behavior, see \secref{Sec:ParticlesUnitTest}.


%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------

\section{Mesh/Particle Mapping}
\label{Sec:Particles Mapping}

Particles behave in a fundamentally different way than grid-based quantities.
Lagrangian, or passive particles are essentially independent of the grid mesh and move
along with the velocity field.  Active particles may be located independently of mesh refinement.
In either case, there is a need to convert grid-based quantities into similar attributes defined
on particles, or vice versa.
The method for interpolating mesh quantities to tracer particle positions must
be consistent with the numerical method to avoid introducing systematic
error. In the case of a finite-volume methods such as those used in \flashx, the mesh
quantities have cell-averaged rather than point values, which requires
that the interpolation function for the particles also represent
cell-averaged values. Cell averaged quantities are defined as
\begin{equation}
f_i\left(x\right) \: \equiv \: \frac{1}{\Delta x} \int_{x_{i-1/2}}^{x_{i-1/2}}
f\left(x^\prime \right) dx^\prime
\end{equation}
where $i$ is the cell index and $\Delta x$ is the spatial
resolution.
The mapping back and forth from the mesh to the particle properties
are defined in the routines \code{Particles_\-mapFromMesh} and
\code{Particles_\-mapToMeshOneBlk}.

Specifying the desired mapping method is accomplished by designating the \code{MAPMETHOD}
in the Simulation \code{Config} file for each type of particle.
See \secref{Sec:FlashHparttypes} for more details.



\subsection{Quadratic Mesh Mapping}

The quadratic mapping package defines an interpolation back and forth
to the mesh which is second order. This implementation is primarily
meant to be used with passive tracer particles.

To derive it, first consider a
second-order interpolation function of the form
\begin{equation}
f\left(x\right) \: = \: A + B \left(x - x_i\right) + C \left(x - x_i\right)^2 \; .
\end{equation}
Then integrating gives
\begin{eqnarray}
f_{i-1} \: & = & \: \frac{1}{\Delta x}\left[ A + \left. \frac{1}{2}
B \left(x - x_i\right)^2 \right|^{x_{i-1/2}}_{x_{i-3/2}} + \left. \frac{1}{3}
C \left(x - x_i\right)^3 \right|^{x_{i-1/2}}_{x_{i-3/2}} \right]\nonumber  \\
           & = & \: A - B\Delta x + \frac{13}{12} C \Delta x^2 \;,
\end{eqnarray}
\begin{eqnarray}
f_{i} \: & = & \: \frac{1}{\Delta x}\left[ A + \left. \frac{1}{2} B \left(x - x_i\right)^2 \right|^{x_{i+1/2}}_{x_{i-1/2}}
+ \left. \frac{1}{3}  C \left(x - x_i\right)^3 \right|^{x_{i+1/2}}_{x_{i-1/2}}  \right]\nonumber \\
           & = & \: A + \frac{1}{12} C \Delta x^2 \; ,
\end{eqnarray}
and
\begin{eqnarray}
f_{i+1} \: & = & \: \frac{1}{\Delta x}\left[ A + \left.\frac{1}{2} B \left(x - x_i\right)^2 \right|^{x_{i+3/2}}_{x_{i+1/2}}.
+ \left. \frac{1}{3}  C \left(x - x_i\right)^3 \right|^{x_{i-1/2}}_{x_{i-3/2}} \right]\nonumber  \\
           & = & \: A - B\Delta x + \frac{13}{12} C \Delta x^2 \;,
\end{eqnarray}
We may write these as
\begin{equation}
\left[ \begin{array}{c}
f_{i+1} \\ f_{i} \\ f_{i-1}
\end{array} \right] \: = \:
\left[ \begin{array}{ccc}
1 & -1 & \frac{13}{12} \\ 1 & 0 & \frac{1}{12} \\ 1 & 1 & \frac{13}{12}
\end{array} \right]
\left[ \begin{array}{ccc}
A \\ B\Delta x \\ C \Delta x^2
\end{array} \right] \; .
\end{equation}
Inverting this gives expressions for $A$, $B$, and $C$,
\begin{equation}
\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2
\end{array} \right] \: = \:
\left[ \begin{array}{ccc}
-\frac{1}{24} & \frac{13}{12} & -\frac{1}{24} \\ -\frac{1}{2} & 0 & \frac{1}{2} \\
\frac{1}{2} & -1 & \frac{1}{2}
\end{array} \right]
\left[ \begin{array}{ccc}
f_{i+1} \\ f_{i} \\ f_{i-1}
\end{array} \right] \; .
\end{equation}

In two dimensions, we  want a second-order interpolation function of the form
\begin{equation}
f\left(x,y\right) \: = \: A + B \left(x - x_i\right) + C \left(x - x_i\right)^2
+ D \left(y - y_j\right) + E \left(y - y_j\right)^2 +
F \left(x - x_i\right)\left(y - y_j\right) \; .
\end{equation}
In this case, the cell averaged quantities are given by
\begin{equation}
f_{i,j}\left(x,y\right) \: \equiv \: \frac{1}{\Delta y}{\Delta x} \int_{x_{i-1/2}}^{x_{i+1/2}}
dx^\prime
\int_{y_{j-1/2}}^{x_{j-1/2}}  dy^\prime
f\left(x^\prime,y^\prime \right) \; .
\end{equation}
Integrating the 9 possible cell averages gives, after some algebra,
\begin{equation}
\left[ \begin{array}{c}
f_{i-1,j-1} \\ f_{i,j-1} \\ f_{i+1,j-1} \\
f_{i-1,j} \\ f_{i,j} \\ f_{i+1,j} \\
f_{i-1,j+1} \\ f_{i,j+1} \\ f_{i+1,j+1}
\end{array} \right] \: = \:
\left[ \begin{array}{cccccc}
1 & -1 & \frac{13}{12} & -1 &  \frac{13}{12} &  1 \\
1 &  0 & \frac{1}{12}  & -1 &  \frac{13}{12} &  0 \\
1 &  1 & \frac{13}{12} & -1 &  \frac{13}{12} & -1 \\
1 & -1 & \frac{13}{12} &  0 &  \frac{1}{12}  &  0 \\
1 &  0 & \frac{1}{12}  &  0 &  \frac{1}{12}  &  0 \\
1 &  1 & \frac{13}{12} &  0 &  \frac{1}{12}  &  0 \\
1 & -1 & \frac{13}{12} &  1 &  \frac{13}{12} & -1 \\
1 &  0 & \frac{1}{12}  &  1 &  \frac{13}{12} &  0 \\
1 &  1 & \frac{13}{12} &  1 &  \frac{13}{12} &  1
\end{array} \right]
\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2 \\
D \Delta y \\ E \Delta y^2 \\ F \Delta x \Delta y
\end{array} \right] \; .
\end{equation}
At this point we note that there are more constraints than unknowns,
and we must make a choice of the constraints. We chose to ignore
the cross terms and take only the face-centered cells next to
the cell containing the particle, giving
\begin{equation}
\left[ \begin{array}{c}
f_{i,j-1} \\ f_{i-1,j} \\ f_{i,j} \\
f_{i+1,j} \\ f_{i,j+1}
\end{array} \right] \: = \:
\left[ \begin{array}{cccccc}
1 &  0 & \frac{1}{12}  & -1 &  \frac{13}{12}  \\
1 & -1 & \frac{13}{12} &  0 &  \frac{1}{12}   \\
1 &  0 & \frac{1}{12}  &  0 &  \frac{1}{12}   \\
1 &  1 & \frac{13}{12} &  0 &  \frac{1}{12}   \\
1 &  0 & \frac{1}{12}  &  1 &  \frac{13}{12}
\end{array} \right]
\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2 \\
D \Delta y \\ E \Delta y^2
\end{array} \right] \; .
\end{equation}
Inverting gives
\begin{equation}
\left[ \begin{array}{c}
A \\ B\Delta x \\ C \Delta x^2 \\
D \Delta y \\ E \Delta y^2
\end{array} \right]
\: = \:
\left[ \begin{array}{cccccc}
-\frac{1}{24} & -\frac{1}{24}  & \frac{7}{6}  & -\frac{1}{24}  & -\frac{1}{24}  \\
0             & -\frac{1}{2}   & 0            &  \frac{1}{2}   &  0   \\
0             & \frac{1}{2}    & -1           &  \frac{1}{2}   &  0   \\
-\frac{1}{2}  &  0             & 0            &  0             &  \frac{1}{2}   \\
\frac{1}{2}    &  0             & -1           &  0             &  \frac{1}{2}
\end{array} \right]
\left[ \begin{array}{c}
f_{i,j-1} \\ f_{i-1,j} \\ f_{i,j} \\
f_{i+1,j} \\ f_{i,j+1}
\end{array} \right]  \; .
\end{equation}
Similarly, in three dimensions, the interpolation function is
\begin{equation}
f\left(x,y,z\right) \: = \: A + B \left(x - x_i\right) + C \left(x - x_i\right)^2
+ D \left(y - y_j\right) + E \left(y - y_j\right)^2 +
F \left(z - z_k\right) + G  \left(z - z_k\right)^2 \; .
\end{equation}
and we have
\begin{equation}
\left[ \begin{array}{c}
A \\ B \Delta x \\ C {\Delta x}^2 \\
D \Delta y \\ E {\Delta y}^2 \\ F \Delta z \\ G {\Delta z}^2
\end{array} \right]
\: = \:
\left[ \begin{array}{ccccccc}
-\frac{1}{24} & -\frac{1}{24} & -\frac{1}{24} & \frac{5}{4} & -\frac{1}{24} & -\frac{1}{24} & -\frac{1}{24} \\
0             & 0             & -\frac{1}{2}  & 0           &  \frac{1}{2}  & 0             &  0   \\
0             & 0             &  \frac{1}{2}  & -1          &  \frac{1}{2}  & 0             &  0   \\
0             & -\frac{1}{2}  &  0            &  0          &  0            & \frac{1}{2}   &  0   \\
0             &  \frac{1}{2}  &  0            & -1          &  0            & \frac{1}{2}   &  0   \\
-\frac{1}{2}  & 0             &  0            &  0          &  0            & 0             &  \frac{1}{2}   \\
 \frac{1}{2}  & 0             &  0            & -1          &  0            & 0             &  \frac{1}{2}
\end{array} \right]
\left[ \begin{array}{c}
f_{i,j,k-1} \\ f_{i,j-1,k} \\ f_{-i,j,k} \\
f_{i,j,k} \\ f_{i+1,j,k} \\ f_{i,j+1,k} \\ f_{i,j,k+1}
\end{array} \right]  \; .
\end{equation}
Finally, the above expressions apply only to Cartesian coordinates. In the case of
cylindrical $\left(r,z\right)$ coordinates, we have
\begin{eqnarray}
f\left(r,z\right) \; = & & \nonumber \\
& A + B \left(r - r_i\right) + C \left(r - r_i\right)^2
+ D \left(z - z_j\right) & \nonumber \\
& + E \left(z - z_j\right)^2 +
F \left(r - r_i\right)\left(z - z_j\right) \; . &
\end{eqnarray}
and
\begin{eqnarray}
\left[ \begin{array}{c}
A \\ B\Delta r \\ C\Delta r^{\frac{2}{6}} \\ D\Delta z  \\ E \Delta z^2
\end{array} \right] \: = \hspace{-1.0in} & & \nonumber \\
& \left[ \begin{array}{cccccc}
-\frac{1}{24} & -\frac{h_1-1}{24h_1}  & \frac{7}{6}      & -\frac{h_1-1}{24h1}  & -\frac{1}{24} \\
0
& - \frac{\left(7+6h_1\right)\left(h_1-1\right)}{3h_2}
& \frac{2h_1}{3h2}
& \frac{\left(7+6h_1\right)\left(h_1-1\right)}{3h_2}
& 0  \\
0
& \frac{\left(12h_1^2 + 12 h_1 - 1\right)\left(h_1 - 1\right)}{h_1h_2}
& -2 \frac{12 h_1^2 -13}{h_2}
& - \frac{\left(12h_1^2 + 12 h_1 - 1\right)\left(h_1 - 1\right)}{h_1h_2}
& 0 \\
- \frac{1}{2}
& 0
& 0
& \frac{1}{2}
& 0 \\
0
& \frac{1}{2}
& - 1
& \frac{1}{2}
& 0 \\
\end{array} \right]
\left[ \begin{array}{c}
f_{i,j-1} \\ f_{i-1,j} \\ f_{i,j} \\
f_{i+1,j} \\ f_{i,j+1}
\end{array} \right]  \; . &
\end{eqnarray}


\subsection{Cloud in Cell Mapping}
\label{Sec:CIC}
Other interpolation routines can be defined that take into account
the actual quantities defined on the grid.  These ``mesh-based''
algorithms are represented in \flashx by the Cloud-in-Cell
mapping, where the interpolation to/from the particles is defined
as a simple linear weighting from nearby grid points.  The weights are
defined by considering only the region of one ``cell'' size around
each particle location; the proportional volume of the particle
``cloud'' corresponds to the amount allocated to/from the mesh. The
\code{CIC} method can be used with both types of particles. When using it
with active particles the MapToMesh methods should also be
selected. In order to include the CIC method with passive particles,
the \code{setup} command line option is
\code{-with-unit=Particles/ParticlesMapping/CIC}. Two additional
command line option
\code{-with-unit=Particles/ParticlesMapping/MapToMesh} and
\code{-with-unit=Grid/GridParticles/MapToMesh} are necessary 
when using the active particles. All of these command line options can
be replaced by placing the appropriate \code{REQUIRES/REQUESTS}
directives in the Simulation \code{Config} file.

\section{Using the Particles Unit}
\label{Sec:ParticlesUsing}
The Particles unit encompasses nearly all aspects of Lagrangian
particles.  The exceptions are input/output
the movement of related data structures
between different blocks as the particles move from one block to
another, and 
mapping the particle attributes to and from the grid. 

Particle 
types must be specified in the \code{Config} file of the Simulations
unit setup directory for the application, and the syntax is explained
in \secref{Sec:FlashHparticles}.
At configuration time, the setup script parses the \code{PARTICLETYPE}
specifications in the Config files, and generates an F90 file 
\api{Particles/Particles_specifyMethods}\code{.F90}
that
populates a data structure \code{gr_ptTypeInfo}. This data structure
contains information about the method of initialization and
interpolation methods for mapping the particle attributes to and from
the grid for each included particle type. Different time integration
schemes are applied to active and passive 
particles. However, in one simulation, all active particles are
integrated using the same 
scheme, regardless of how many active types exists. 
Similarly, only one passive integration scheme is used.
The added complexity of multiple particle types allows different methods
to be used for initialization of particles positions and their
mapping to and from the grid quantities.
Because several different implementations of each type of
functionality can co-exist in one simulation, there are no defaults in
the \code{Particles} unit \code{Config} files. These various functionalities are organized
into different \subunits; a brief description of each subunit is 
included below and further expanded in subsections in this chapter.  

\begin{itemize}

 \item The \code{ParticlesInitialization} subunit distributes a given
set of particles through the spatial domain at the simulation startup. Some
type of spatial initialization is always required; the functionality
is provided by \api{Particles/Particles_initPositions}. The users of active
particles typically have their own custom initialization. The
following two implementations of initialization techniques are
included in the \flashx distribution (they are more likely to
used with the passive tracer particles): 

      \begin{description}
      \item[\code{Lattice}] distributes particles regularly along the
	axes directions throughout a subsection of the physical grid.
      \item[\code{WithDensity}] distributes particles randomly, with
	particle density being proportional to the grid gas density.
      \end{description}

Users have two options for implementing custom initialization
methods. The two files involved in the process are:
\api{Particles/Particles_initPositions} and pt\_initPositions. The
former does some housekeeping such as allowing for inclusion
of one of the available methods along with the user specified one, and
assigning tags at the end. A user wishing to add one custom method
with no constraints on tags etc is advised to implement a custom
version of the latter. This approach allows the user to focus the
implementation on the placement of particles only. Users desirous of
refining the grid based on particles count during initialiation should
see the setup \code{PoisParticles} for an example implementation of
the Particles\_initPositions routine. If more than one implementation
of pt\_initPositions is desired in the same simulation then it is
necessary to implement each one separately with different names (as we
do for tracer particles: pt\_initPositionsLattice and
pt\_initPositionsWithDensity) in their simulation setup directory. In
addition, a modified copy of Particles\_initPostions, which calls
these new routines in the loop over types, must also be
placed in the same directory.

\item The \code{ParticlesMain} \subunit contains the various
  time-integration options for both active and passive particles.  A 
  detailed overview of the different schemes is given in
  \secref{Sec:Particles Integration}. 


\item The \code{ParticlesMapping} \subunit controls the mapping of particle properties to and from the grid.
      Flash-X currently supplies the following mapping schemes:
      \begin{description}
%\begin{comment}
      %\item nearest grid point (\code{mapping/ngp}),
      \item[\code{Cloud-in-cell}] (\code{ParticlesMapping/\-meshWeighting/\-CIC}), which weights values at nearby grid cells;  and
%\end{comment}
        \item[\code{Quadratic}] (\code{ParticlesMapping/\-Quadratic}), which performs quadratic interpolation.
    %\item  triangular-shaped cloud  (\code{mapping/tsc}), and cloud-in-cell for 1D spherical and 2D
    %      axisymmetric cylindrical coordinates (\code{mapping/cic\_1dsph} and
    %  \item    \code{mapping/cic\_2dcylaxi}, respectively).
      \end{description}

\end{itemize}
      
      Some form of mapping must always be included when running a
simulation with particles. As mentioned in \secref{Sec:Particles
Mapping} the quadratic mapping scheme is only available to map {\em from} the
grid quantities to the corresponding particle attributes. Since active
particles require the same mapping scheme to be used in mapping to and
from the mesh, they cannot use the quadratic mapping scheme as
currently implemented in \flashx. The CIC scheme may be used by both
the active and passive particles. 


After particles are moved during time integration or by forces, 
they may end up on other blocks within or
without the current processor.  The redistribution of particles
among processors is handled by the \unit{GridParticles} subunit, as the
algorithms required vary considerably between the grid
implementations.  The boundary conditions are also implemented by
the GridParticles unit.  See \secref{Sec:GridParticles} for more details of these
redistribution algorithms.  The user should include the option \code{-with-unit=Grid/\-GridParticles} on the
setup line, or \code{REQUIRES Grid/\-GridParticles} in the Config file.

In addition, the input-output routines for the Particles unit are contained in a
subunit \unit{IOParticles}.  Particles are written to the main checkpoint files.
If the user desires, a separate output file can be created which contains only the
particle information.  See \secref{Sec:Particles IO} below as well as
\secref{Sec:IOParticles} for more details.  The user should include the option
\code{-with-unit=IO/\-IOParticles} on the setup line, or \code{REQUIRES IO/\-IOParticles} in the Config file.

In \flashx, the initial particle positions can be used to
construct an appropriately refined grid, i.e. more refined in places
where there is a clustering of particles.  To use this feature the
\code{flash.par} file must include:
\code{refine_on_particle_count=.true.} and
\code{max_particles_per_blk=[some value]}.  Please be aware that Flash-X
will abort if the criterion is  too demanding.  To overcome the abort,
specify a less demanding criterion, or increase the value of
\code{lrefine_max}.  

\subsection{Particles Runtime Parameters}
\label{Sec:Particles Runtime Parameters}

There are several general runtime
parameters applicable to the \code{Particles} unit, which affect every implementation.
The variable \rpi{Particles/useParticles} obviously must be set equal to \code{.true.} to utilize
the Particles unit.  The time stepping is controlled with \rpi{Particles/pt_dtFactor};
a value less than one ensures that particles will not step farther than one entire cell in any
given  time interval.  The \code{Lattice} initialization routines have additional parameters.
The number of evenly spaced particles is controlled in each direction by
\rpi{Particles/pt_numX} and similar variables in $Y$ and $Z$.
The physical range of initialization is controlled by \rpi{Particles/pt_initialXMin}
and the like.
Finally, note that the output of particle properties to special particle files is controlled by
runtime parameters found in the \code{IO} unit.  See \secref{Sec:Particle files} for more details.

% \begin{comment}
% \tblref{Tab:particle_parameters} and indicated with the module notation "Main".
% Additional parameters are applicable only to the module indicated.
% 
% \begin{center}
% \begin{longtable}{llllp{3in}}
% \caption{ \label{Tab:particle_parameters} Runtime parameters used with
% the \code{Particles} unit} \\
% 
% 
% Variable                   & Module   & Type     & Default  & Description\\
% \hline
% \code{useParticles}               &Main & boolean  & True   & If true, evolve particles\\
% \code{pt_dtFactor}    &Main &  real     & 0.5 & Maximum distance (in cells) a
%                                              particle is allowed to travel in
%                                              one timestep. Should not be set
%                                              larger than the number of guard
%                                              cells.\\
% \code{pt_maxPerProc} &Main & integer  & 1000   & Maximum number of particles per
%                                              processor (sets size of particle
%                                              buffers)\\
% \code{pt_numX|Y|Z}       &Lattice & integer  & 1   & Sets the number of
%                                              particles along the $x,y,$ or $z$-dimension
%                                              of the physical grid\\
% 
% \code{pt_initialX|Y|Z|Min|Max}  & Lattice & real & 0.0 | 1.0 &
%                             Range in the physical domain where particles should be evenly
%                             distributed.\\
% \code{pt_numParticlesWanted}    &WithDensity & integer & 1 & Approximate number
%                             of particles desired throughout entire grid\\
% \code{pt_pRand}            &WithDensity & integer& 100000 & Random seed\\
% 
% code{particle_attribute_1|2..} & Main & string & &attributes that
% should be output \\
% \hline
% 
% \end{longtable}
% \end{center}
% \end{comment}



\subsection{Particle Attributes}
\label{Sec:Particle Properties}

By default, particles are defined to have eight real properties or attributes:  3 positions in x,y,z; 3 velocities
in x,y,z; the current block identification number; 
and a tag which uniquely identifies the particle.
Additional properties can be defined for each particle.  For example, active particles usually
have the additional properties of mass and acceleration (needed for the integration routines, see
Table \tblref{Tab:active particle attributes}).
Depending upon the simulation, the user can define particle properties
in a manner similar to that used
for mesh-based solution variables.
To define a particle attribute, add to
a \code{Config} file a line of the form
\begin{quote}
\code{PARTICLEPROP} {\it property-name}
\end{quote}

For attributes that are meant to merely sample and record the state of
certain mesh variables along trajectories, Flash-X can automatically
invoke interpolation (or, in general, some map method) to generate
attribute values from the appropriate grid quantities.
(For passive tracer particles, these are typically the only attributes
beyond the default set of eight mentioned above.)
The routine \api{Particles/Particles_updateAttributes} is invoked
by Flash-X at appropriate times to effect this mapping, namely before
writing particle data to checkpoint and particle plot files.
To direct the default implementation of \code{Particles\_updateAttributes}
to act as desired for tracer attributes, the user must define 
the association of the particle attribute
with the appropriate mesh variable by including the following line in
the \code{Config} file:
\begin{quote}
\code{PARTICLEMAP TO} {\it property-name} \code{FROM VARIABLE} {\it variable-name}
\end{quote}

These particle attributes are carried along in the simulation and
output in the checkpoint files. At runtime, the user can specify the attributes
to output through runtime parameters 
\newline
\rpi{Particles/particle_attribute_1},
\rpi{Particles/particle_attribute_2}, etc. These specified attributes
are collected in an array by the \api{Particles/Particles_init}
routine. This array in turn is used by
\api{Particles/Particles_updateAttributes} to calculate the values of the
specified attributes from the corresponding mesh quantities before
they are output.  

\subsection{Particle I/O}
\label{Sec:Particles IO}

Particle data are written to and read from checkpoint files by
the I/O modules (\chpref{Sec:Flash-X output formats}). For more
information on the format of particle data written to output files,
see \secref{Sec:HDF5} and \secref{Sec:PnetCDF IO}.

Particle data can also be written out to the \code{flash.dat} file.  The user should
include a local copy of \api{IO/IO_writeIntegralQuantities} in their Simulation directory.
The \code{Orbit} test problem supplies an example \code{IO_writeIntegralQuantities}
routine that is useful for writing individual
particle trajectories to disk at every timestep.

There is also a utility routine \api{Particles/Particles_dump} which can be used to dump
particle output to a plain text file.  An example of usage can be found in
 \api{Particles/Particles_unitTest}.  Output from this routine can be
read using the fidlr routine \code{particles_dump.pro}.

