\chapter{The Flash-X configuration script (\code{setup})}
\label{Chp:The Flash-X configuration script}

\newcommand{\setup}{\code{setup}\xspace}

The \setup tool is the most important component of the \OS. It
implements the inheritance and composability of the \flashx software
system. It traverses the Flash-X source tree starting from the
directory hosting the specific application definition. This starting
directory is essentially the selected implementation of the
``Simulation'' unit. While traversing the source three the setup tool
does the following:
\begin{itemize}
\item arbitrate on map from a key to its definition, in particular if
  alternative definitions exist
\item arbitrate on which implementation of a function to use 
\item link selected files (include source code and the key
  definitions) to the \code{object/} directory
\item invoke macroprocessor to translate keys and generate source
  file
\item alter index order if desired
\item find the target \code{Makefile.h} %\index{Makefile.h} for a given machine.
\item generate the \code{Makefile} that will build the Flash-X executable.
\item generate the files needed to add runtime parameters to a given simulation.
\item generate the files needed to parse the runtime parameter file.
\end{itemize}

More description of how \setup and the \flashx architecture interact  may be found in
\chpref{Chp:Architecture}. Here we describe its usage.

The \setup script determines site-dependent configuration information
by looking for a directory
\newline % preventing overfull
\code{sites/<hostname>} where \code{<hostname>}
is the hostname of the machine on which Flash-X is running.\footnote{if a machine
has multiple hostnames, setup tries them all} Failing this, it looks in
\code{sites/Prototypes/} for a directory with the same name as the output
of the \code{uname} command.  The site and operating system type can be
overridden with the \code{-site} and \code{-ostype} command-line options to
the \setup command. 
Only one of these options can be used at one time.
The directory for each site and operating system type contains a makefile
fragment \code{Makefile.h} that sets command names, compiler flags,
library paths, and any replacement or additional source files needed
to compile Flash-X for that specific machine and machine type.

The \setup script starts with the \code{Config} file of the specified
application in the Simulation unit, finds its
\code{REQUIRED} units and then works its way through their
\code{Config} files. This process continues until all the dependencies
are met and a self-consistent set of units has been found. At the end
of this automatic generation,
the \code{Units} file is created and placed in the \code{object/}
directory, where it can be edited if necessary. \setup also creates
the master makefile (\code{object/Makefile}) and several \FORTRAN\
include files that are needed by the code in order to parse the
runtime parameters. After running \setup, the user can create the
Flash-X executable by running \code{make} in the \code{object}
directory.
Note that the Flash-X build system assumes that the command \code{make} invokes GNU Make
and is unlikely to work properly with other implementations of the \code{make}
command. On some systems it may be necessary to invoke GNU Make under the name \code{gmake}.


\begin{flashtip}[Save some typing]
\begin{itemize}
\protect\item
All the setup options can be shortened to unambiguous prefixes,
\eg\ instead of \verb|./setup -auto <problem-name>| one can just say
\verb|./setup -a <problem-name>| since there is only one \setup
option starting with \code{a}.

\protect\item
The same abbreviation holds for the problem name as well. \code{./setup -a IsentropicVortex}
can be abbreviated to \code{./setup -a Isen}
assuming that \code{IsentropicVortex} is the only problem name which
starts with \code{Isen}.

\protect\item
Unit names are usually specified by their paths relative to the source
directory. However, \setup also allows unit names to be prefixed with an
extra ``source/'', allowing you to use the TAB-completion features of your
shell like this
\begin{codeseg}
./setup -a Isen -unit=sou<TAB>rce/IO/IOM<TAB>ain/hd<TAB>f5
\end{codeseg}

\protect\item
If you use a set of options repeatedly, you can define a shortcut for
them. \flashx comes with a number of predefined shortcuts that
significantly simplify the setup line, particularly when trying to
match the Grid with a specific I/O implementation. 
For more details on creating shortcuts see
\secref{Sec:SetupShortcuts}.
For detailed examples of I/O shortcuts please see
\secref{Sec:IO example setups}in the I/O chapter.
\end{itemize}
\end{flashtip}


\section{Setup Arguments}

The setup script accepts a large number of command line arguments
which affect the simulation in various ways. These arguments are divided
into three categories:

\begin{enumerate}
  \item \textit{Setup Options} (example: \code{-auto}) begin with a
    dash and are built into the setup script itself. Many of the most
    commonly used arguments are setup options.
  \item \textit{Setup Variables} (example: \code{species=air,h2o})
    are defined by individual units. When writing a \code{Config} file
    for any unit, you can define a setup
    variable. \secref{Sec:setupvariables} explains how setup variables
    can be created and used.
  \item \textit{Setup Shortcuts} (example: \code{+ug}) begin with a
    plus symbol and are essentially macros which automatically include
    a set of setup variables and/or setup options. New setup shortcuts
    can be easily defined, see \secref{Sec:SetupShortcuts} for more
    information.
\end{enumerate}

\tblref{Tbl:CommonSetupArgs} shows a list of some of the basic setup
arguments that every Flash-X user should know about. A comprehensive
list of all setup arguments can be found in \secref{Sec:ListSetupArgs}
alongside more detailed descriptions of these options.

\begin{table}
\caption{ \label{Tbl:CommonSetupArgs} List of Commonly Used Setup Arguments}
\begin{center}
\begin{tabular}{l|l}
\hline
\multicolumn{1}{c|}{\textbf{Argument}} & \multicolumn{1}{c}{\textbf{Description}}   \\
\hline
\grayrow \code{-auto}         & this option should almost always be set             \\
         \code{-unit=<unit>}  & include a specified unit                            \\
\grayrow \code{-objdir=<dir>} & specify a different object directory location       \\
         \code{-debug}        & compile for debugging                               \\
\grayrow \code{-opt}          & enable compiler optimization                        \\
         \code{-n[xyb]b=\#}   & specify block size in each direction                \\
\grayrow \code{-maxblocks=\#} & specify maximum number of blocks per process        \\
         \code{-[123]d}       & specify number of dimensions                        \\
\grayrow \code{-maxblocks=\#} & specify maximum number of blocks per process        \\
         \code{+cartesian}    & use Cartesian geometry                              \\
\grayrow \code{+cylindrical}  & use cylindrical geometry                            \\
         \code{+polar}        & use polar geometry                                  \\
\grayrow \code{+spherical}    & use spherical geometry                              \\
         \code{+noio}         & disable IO                                          \\
\grayrow \code{+ug}           & use the uniform grid in a fixed block size mode     \\
         \code{+nofbs}        & use the uniform grid in a non-fixed block size mode \\
\grayrow \code{+pm2}          & use the PARAMESH2 grid                              \\
         \code{+pm40}         & use the PARAMESH4.0 grid                            \\
\grayrow \code{+pm4dev}       & use the PARAMESH4DEV grid                           \\
         \code{+uhd}          & use the Unsplit Hydro solver                        \\
\grayrow \code{+usm}          & use the Unsplit Staggered Mesh MHD solver           \\
         \code{+splitHydro}   & use a split Hydro solver                            \\
\hline
\end{tabular}
\end{center}
\end{table}

\section{Comprehensive List of Setup Arguments} \label{Sec:ListSetupArgs}

% \section{Basic Setup Options}\label{Sec:SetupBasic}

%% The various \setup options are given below. The \emph{basic} options
%% are enough to make use of the full functionality of the \setup
%% script. The \emph{advanced} options of \secref{Sec:ListSetupArgs} often help save time while
%% compiling/debugging your code.

%begin{latexonly}
\newcommand{\tabopt}[1]{\multicolumn{2}{l}{#1}\\*[1ex]}
\newcommand{\tr}{\\[1ex]}
%end{latexonly}
% \begin{htmlonly}
% \newcommand{\tabopt}[1]{\multicolumn{2}{l}{#1}\\}
% \newcommand{\tr}{\\}
% \end{htmlonly}


\begin{longtable}{p{0.04\textwidth}p{0.9\textwidth}}
\tabopt{\code{-verbose=<verbosity>}}%\index{setup!-verbose@\code{-verbose}}}
 &
Normally \setup prints summary messages indicating its progress. Use
the \code{-verbose} to make the messages more or less verbose. The
different levels (in order of increasing verbosity) are
\code{ERROR,IMPINFO,WARN,INFO,DEBUG}. The default is
\code{WARN}.\tr

\tabopt{\code{-auto}}%\index{setup!-auto@\code{-auto}}}
 & Normally, \setup requires that the user supply a
plain text file called \code{Units} (in the \code{object}
directory
\footnote{Formerly, (in Flash-X2) it was located in the Flash-X
root directory}) 
that specifies the units to include. A sample
\code{Units} file appears in \figref{Fig:Units file example}. Each
line is either a comment (preceded by a hash mark (\code{\#})) or
the name of a an include statement of the form \code{INCLUDE
}\emph{unit}. Specific implementations of a unit may be selected by
specifying the complete path to the implementation in question; If
no specific implementation is requested, \setup picks the default
listed in the unit's \code{Config} file. \tr & The \code{-auto} option
enables \setup to generate a ``rough draft'' of a \code{Units} file
for the user. The \code{Config} file for each problem setup specifies
its requirements in terms of other units it requires. For example, a
problem may require the perfect-gas equation of state
(\code{physics/Eos/EosMain/Gamma}) and an unspecified hydro solver
(\code{physics/Hydro}).  With \code{-auto}, \setup creates a
\code{Units} file by converting these requirements into unit
include statements. Most users configuring a problem
for the first time will want to run \setup with \code{-auto} to
generate a \code{Units} file and then to edit it
directly to specify alternate implementations of certain units.
After editing the \code{Units} file, the user must re-run \setup without
\code{-auto} in order to incorporate his/her changes into the code configuration.
The user may also use the command-line option \code{-with-unit=<path>} in
conjunction with the \code{-auto} option, in order to pick a specific implementation
of a unit, and thus eliminate the need to hand-edit the \code{Units} file. \tr

\tabopt{\code{-[123]d}}%\index{setup!-[123]d@\code{-[123]d}}}
 &
By default, \setup creates a makefile which produces a Flash-X executable
capable of solving two-dimensional problems (equivalent to \code{-2d}).
To generate a makefile with options appropriate to three-dimensional problems,
use \code{-3d}. To generate a one-dimensional code, use \code{-1d}.
These options are mutually exclusive and cause \setup to add the appropriate
compilation option to the makefile it generates.\tr

\tabopt{\code{-maxblocks=\#}}%\index{setup!-maxblocks@\code{-maxblocks}}}
 & %\index{MAXBLOCKS@\code{MAXBLOCKS}}This option is also used by
\setup in constructing the makefile compiler options. It determines
the amount of memory allocated at runtime to the adaptive mesh
refinement (AMR) block data structure. For example, to allocate
enough memory on each processor for 500 blocks, use
\code{-maxblocks=500}. If the default block buffer size is too large
for your system, you may wish to try a smaller number here; the default
value depends upon the dimensionality of the simulation and the grid type.
Alternatively, you may wish to experiment with larger buffer sizes,
if your system has enough memory.  A common cause of aborted simulations
occurs when the AMR grid creates greater than \code{maxblocks} during refinement.
Resetup the simulation using a larger value of this option. \tr

\tabopt{\code{-nxb=\# -nyb=\# -nzb=\#}}
% \index{setup!-n[xyz]b@\code{-n[xyz]b}}} & %
These options are used by \setup in constructing the makefile
compiler options.  The mesh on which the problem is solved is
composed of blocks, and each block contains some number of cells.
The \code{-nxb}, \code{-nyb}, and \code{-nzb} options determine how many cells each
block contains (not counting guard cells). The default value
for each is 8. These options do not have any effect
when running in Uniform Grid non-fixed block size mode.\tr

\tabopt{\code{[-debug|-opt|-test]}}%\index{setup!-debug@\code{-debug}}
%\index{setup!-opt@\code{-opt}}%\index{setup!-test@\code{-test}}}
& The default \code{Makefile} built by setup will use the optimized
setting (\code{-opt}) for compilation and linking.  Using \code{-debug}
will force \setup to use the flags relevant for debugging (\eg, including
\code{-g} in the compilation line). The user may use the option \code{-test}
to experiment with different combinations of compiler and linker options.
Exactly which compiler and linker options are associated with each of
these flags is specified in \code{sites/<hostname>/Makefile*} where \code{<hostname>}
is the hostname of the machine on which Flash-X is running.

For example, to tell an Intel Fortran compiler to use real numbers of size
64 when the \code{-test} option is specified, the user might add the following
line to his/her \code{Makefile.h}:
\begin{codeseg}
FFLAGS_TEST = -real_size 64
\end{codeseg}
\tr

%\begin{comment}
% % This chapter porting_flash.tex not included in alpha release
% Please see \chpref{Chp:Porting Flash-X to other machines} for more information
% about writing your own Makefile.h
% \end{comment}

\tabopt{\code{-objdir=<dir>}}%\index{setup!-objdir@\code{-objdir}}} &
Overrides the default \code{object} directory with \code{<dir>}.
Using this option allows you to have different simulations configured simultaneously in the \flashx
distribution directory. \tr

\tabopt{ \code{-with-unit=<unit>}, \code{-unit=<unit>}}
%\index{setup!-unit@\code{-unit}}
%\index{setup!-with-unit@\code{-with-unit}}} & Use the specified
\code{<unit>} in setting up the problem. \tr

%\begin{comment}
%\tabopt{\code{-nonpermanentguardcells}%
%%\index{setup!-nonpermanentguardcells@\code{-nonpermanentguardcells}}}
%& This is a feature supported by \Paramesh 3 to save memory, it is
%not fully supported in this release and should be used with caution.
%\end{comment}
\end{longtable}

\begin{figure}
\begin{fcodeseg}
#Units file for Sod generated by setup

INCLUDE Driver/DriverMain/Split
INCLUDE Grid/GridBoundaryConditions
INCLUDE Grid/GridMain/paramesh/interpolation/Paramesh4/prolong
INCLUDE Grid/GridMain/paramesh/interpolation/prolong
INCLUDE Grid/GridMain/paramesh/paramesh4/Paramesh4.0/PM4_package/headers
INCLUDE Grid/GridMain/paramesh/paramesh4/Paramesh4.0/PM4_package/mpi_source
INCLUDE Grid/GridMain/paramesh/paramesh4/Paramesh4.0/PM4_package/source
INCLUDE Grid/GridMain/paramesh/paramesh4/Paramesh4.0/PM4_package/utilities/multigrid
INCLUDE Grid/localAPI
INCLUDE IO/IOMain/hdf5/serial/PM
INCLUDE IO/localAPI
INCLUDE PhysicalConstants/PhysicalConstantsMain
INCLUDE RuntimeParameters/RuntimeParametersMain
INCLUDE Simulation/SimulationMain/Sod
INCLUDE flashUtilities/contiguousConversion
INCLUDE flashUtilities/general
INCLUDE flashUtilities/interpolation/oneDim
INCLUDE flashUtilities/nameValueLL
INCLUDE monitors/Logfile/LogfileMain
INCLUDE monitors/Timers/TimersMain/MPINative
INCLUDE physics/Eos/EosMain/Gamma
INCLUDE physics/Hydro/HydroMain/split/PPM/PPMKernel
\end{fcodeseg}
\caption{ \label{Fig:Units file example} Example of the \code{Units}
file used by \setup to determine which Units to include}
\end{figure}

% \section{Advanced Setup Options}\label{Sec:ListSetupArgs}

% This section deals with some less commonly used setup options.

\begin{longtable}{p{0.04\textwidth}p{0.9\textwidth}}

\tabopt{\code{-curvilinear}}
% \index{setup!-curvilinear@\code{-curvilinear}}} %
& Enable code in \Paramesh4 that implements geometrically correct
data restriction for curvilinear coordinates.
This setting is automatically enabled if a non-\code{cartesian}
geometry is chosen with the \code{-geometry} flag;
so specifying \code{-curvilinear} only has an effect in
the Cartesian case.
\tr

\tabopt{\code{-defines=<def>[,<def>]\dots}}
% \index{setup!-defines@\code{-defines}}} %
& \code{<def>} is of the form \code{SYMBOL} or \code{SYMBOL=value}.
This causes the specified pre-processor symbols to be defined when
the code is being compiled. This is mainly useful for debugging the
code. For \eg, \code{-defines=DEBUG\_ALL} turns on all debugging
messages. Each unit may have its own \code{DEBUG\_UNIT} flag which
you can selectively turn on. \tr

\tabopt{\code{[-fbs|-nofbs]}}%\index{setup!-fbs@\code{-fbs}}
%\index{setup!-nofbs@\code{-nofbs}}}
& Causes the code to be compiled in fixed-block or non-fixed-block size mode. Fixed-block mode is
the default. In non-fixed block size mode, all storage space is allocated at
runtime. This mode is available only with Uniform Grid.  \tr

\tabopt{\code{-geometry=<geometry>}}%\index{setup!-geometry@\code{-geometry}}} %
& Choose one of the supported geometries \code{cartesian, cylindrical,
  spherical,} or \code{polar}.
Some \unit{Grid} implementations require the geometry to be known
at compile-time while others don't.
This setup option can be used in either case; it is a good idea to
specify the geometry here if it is known at \setup-time.
Choosing a non-Cartesian geometry here automatically sets the
\code{-gridinterpolation=monotonic} option below.\tr

\tabopt{\code{-gridinterpolation=<scheme>}}%\index{setup!-gridinterpolation@\code{-gridinterpolation}}} %
&Select a scheme for \unit{Grid} interpolation.
Two schemes are currently supported:
\begin{itemize}
\item\emterm{monotonic}\newline
This scheme
attempts to ensure that monotonicity is preserved
in interpolation, so that interpolation does not introduce
small-scale non-monotonicity in the data.\newline
The \code{monotonic} scheme is required for curvilinear coordinates
and is automatically enabled if a non-\code{cartesian}
geometry is chosen with the \code{-geometry} flag.
For AMR \unit{Grid} implementations,
This flag will automatically add additional directories
so that appropriate data interpolation methods are
compiled it.
The \code{monotonic} scheme is the default
(by way of the \code{+default} shortcut), unlike in \flashx.  

\item\emterm{native}\newline
Enable the interpolation that is native to
the AMR \unit{Grid} implementation
(\Paramesh2 or \Paramesh4) by default.
This option is only appropriate for Cartesian geometries.
\end{itemize}
\tr

\end{longtable}

\begin{flashtip}[Change in Interpolation]
Note that the default interpolation behavior has changed as of the \flashx beta
release: the \emterm{native} interpolation used to be default. 
\end{flashtip} %\tr

\begin{flashtip}[When to use native Grid interpolation]
The \emterm{monotonic} interpolation method requires more layers of coarse guard cells
next to a coarse guard cell in which interpolation is to be applied.
It may therefore be necessary to use the \emterm{native} method if a simulation
is set up to include fewer than four layers of guard cells.
\end{flashtip}
%\tr

\begin{longtable}{p{0.04\textwidth}p{0.9\textwidth}}
\tabopt{\code{-makefile=<extension>}}%\index{setup!-makefile@\code{-makefile}}} %
& \setup normally uses the \code{Makefile.h} from the
directory determined by the hostname of the machine and
the \code{-site} and \code{-os} options. If you have multiple
compilers on your machine you can create
\code{Makefile.h.<extension>} for different compilers. \eg, you
can have a \code{Makefile.h} and \code{Makefile.h.intel} and
\code{Makefile.h.lahey} for the three different compilers. \setup will
still use the \code{Makefile.h} file by default, but supplying
\code{-makefile=intel} on the command-line causes \setup to use
\code{Makefile.h.intel} instead.\tr

\tabopt{\code{-index-reorder}}%\index{setup!-index-reorder@\code{-index-reorder}}} &
 Instructs \setup that indexing of unk and related arrays should be changed.  
 This may be needed in \flashx for compatibility with alternative grids.  This is supported
 by both the Uniform Grid as well as PARAMESH.\tr

\tabopt{\code{-makehide}}%\index{setup!-makehide@\code{-makehide}}} %
& Ordinarily, the commands being executed during compilation of the
Flash-X executable are sent to standard out. It may be that you find this
distracting, or that your terminal is not able to handle these long
lines of display. Using the option \code{-makehide} causes \setup to
generate a \code{Makefile} so that GNU \code{make} only displays the names
of the files being compiled and not the exact compiler call and flags.
This information remains available in \code{setup\_flags} in the
\code{object/} directory.\tr

\tabopt{\code{-noclobber}}
% \index{setup!-noclobber@\code{-noclobber}}} %
& \setup normally removes all code in the \code{object} directory before
linking in files for a simulation. The ensuing \code{make} must therefore
compile all source files anew each time \setup is run. The \code{-noclobber} option
prevents \setup from removing compiled code which has not changed from the
previous \setup in the same directory. This can speed up the \code{make}
process significantly. \tr

\tabopt{\code{-os=<os>}}%\index{setup!-os@\code{-os}}} %
& If \setup is unable to find a correct \code{sites/} directory it
picks the \code{Makefile} based on the operating system. This option
instructs \setup to use the default \code{Makefile} corresponding to
the specified operating system. \tr

\tabopt{\code{-parfile=<filename>}}
% \index{setup!-parfile@\code{-parfile}}} %
& This causes \setup to copy the specified runtime-parameters file in
the simulation directory to the \code{object} directory with the new name
\code{flash.par} .\tr

\tabopt{\code{-append-parfiles=[location1/]<filename1>[,[location2/]<filename2>]\dots}}
% \index{setup!-append-parfiles@\code{-append-parfiles}}} %
& This option takes a comma-separated list of names of parameter
files and combines them into one \code{flash.par} file in the \code{object} directory.
File names without an absolute path are taken to be relative to the simulation
directory, as for the \code{-parfile} option.

To use such a combined \code{flash.par} in case of runtime parameters occurring more
than once, note that when Flash-X reads a parameter file, the last instance of a runtime
parameter supersedes previous ones.

If both \code{-append-parfiles} and \code{-parfile} are used, the files from the list
are appended to the single parfile given by the latter in the order listed. If used with \code{-parfile},
\code{-append-parfiles} can append one or more parfiles to the one given by \code{-parfile}.
If you only use \code{-append-parfiles} and not \code{-parfile} and give it fewer than two
paths, an error will result.  If more than one \code{-append-parfiles} option appears,
the lists are concatenated in the order given.\tr

\tabopt{\code{-particlemethods=TYPE=<particle type>[,INIT=<init method>]}\code{[,MAP=<map method>][,ADV=<advance method>]}}
\label{setupclf:particlemethods}
%\index{setup!-particlemethods-@\code{-particlemethods}} %
& This option instructs \setup to adjust the particle methods for a
particular particle type.  It can only be used when a particle type
has already been registered with a \code{PARTICLETYPE} line in a
\code{Config} file (see \secref{Sec:FlashHparttypes}).  
A possible scenario for using this option 
involves the user wanting to use a different
passive particle initialization method without modifying the
\code{PARTICLETYPE} line in the simulation \code{Config} file. In this
case, an additional \code{-particlemethods=TYPE=passive,INIT=cellmass}
adjusts the initialization method associated with passive particles in
the \setup generated \code{Particles_specifyMethods()}
subroutine. Since the specification of a method for mapping and
initialization requires inclusions of appropriate implementations of
\code{ParticlesMapping} and \code{ParticlesInitialization} subunits,
and the specification of a method for time advancement
requires inclusion of an appropriate implementation under 
\code{ParticlesMain},
it is the user's responsibility to adjust the included units
appropriately. For example a user may want want to override
\code{Config} file defined particle type \code{passive} using lattice 
initialization \code{CellMassBins} density based distribution method
using the \code{setup} command line. Here the user must first specify 
\code{-without-unit=Particles/ParticlesInitialization/Lattice} to
exclude the lattice initialization, followed by
\code{-with-unit=Particles/ParticlesInitialization/\-WithDensity/\-CellMassBins}
specification to include the appropriate implementation. In general,
using command line overrides of \code{-particlemethods} are not
recommended, as this option increases the chance of creating an inconsistent
simulation setup. More information on multiple particle types can be found in
\chpref{Chp:Particles}, especially \secref{Sec:ParticlesUsing}.
\tr



\tabopt{\code{-portable}}%\index{setup!-portable@\code{-portable}}}
 &
This option causes setup to create a portable \code{object}
directory by copying instead of linking to the source files. The
resulting \code{object} directory can be tarred and sent to
another machine for actual compilation.\tr

\tabopt{\code{-site=<site>}}%\index{setup!-site@\code{-site}}} %
& \setup searches the \code{sites/} directory for a directory whose
name is the hostname of the machine on which setup is being run.
This option tells \setup to use the \code{Makefile} of the specified
site. This option is useful if \setup is unable to find the right
hostname (which can happen on multiprocessor or laptop machines). Also
useful when combined with the \code{-portable} option. \tr

\tabopt{\code{-unitsfile=<filename>}}
% \index{setup!-unitsfile@\code{-unitsfile}}} %
& This causes \setup to copy the specified file to the \code{object}
directory as \code{Units} before setting up the problem. This option
can be used when \code{-auto} is not used, to specify an alternate
\code{Units} file. \tr

\tabopt{\code{-with-library=<libname>[,args]},
\code{-library=<libname>[,args]}}
%\index{setup!-library@\code{-library}}
%\index{setup!-with-library@\code{-with-library}}} %
& This option instructs \setup to link in the specified library when
building the final executable. A \emph{library} is a piece of code
which is independent of Flash-X. Internal libraries are those
libraries whose code is included with Flash-X. The \setup script
supports external as well as internal libraries. Information about
external libraries is usually found in the site specific Makefile.
The additional \code{args} if any are library-specific and may be
used to select among multiple implementations.% For more information
% see \weblink{\makeHowtoURL{Library-HOWTO}}{Library-HOWTO}.
\tr

\tabopt{\code{-tau=<makefile>}}
& This option causes the inclusion of an additional Makefile necessary
for the operation of Tau, which may be used by the user to profile the
code. 
More information on Tau can be found at 
\url{http://acts.nersc.gov/tau/}
\tr

\tabopt{\code{-without-library=<libname>} }%\index{setup!-without-library@\code{-without-library}}} %
& Negates a previously specified \code{-with-library=<libname>[,args]} \tr

\tabopt{\code{-without-unit=<unit>} }%\index{setup!-without-unit@\code{-without-unit}}} %
& This removes all units specified in the command line so far, which are children
of the specified unit (including the unit itself). It also negates any REQUESTS keyword
found in a \code{Config} file for units which are children of the specified unit.
However it does not negate a REQUIRES keyword found in a \code{Config} file. \tr

\tabopt{\code{+default} }%\index{setup!default@\code{default}}} %
& This shortcut specifies using basic default settings and is equivalent to the following:\newline
\code{--with-library=mpi +io +grid-gridinterpolation=monotonic}\tr

\tabopt{\code{+noio} }%\index{setup!noio@\code{noio}}} %
& This shortcut specifies a simulation without IO and is equivalent to the following: \newline
\code{--without-unit=physics/sourceTerms/EnergyDeposition/EnergyDepositionMain/Laser/LaserIO --without-unit=IO}\tr

\tabopt{\code{+io} }%\index{setup!io@\code{io}}} %
& This shortcut specifies a simulation with basic IO and is equivalent to the following:\newline
\code{--with-unit=IO}\tr

\tabopt{\code{+serialIO} }%\index{setup!serialIO@\code{serialIO}}} %
& This shortcut specifies a simulation using serial IO, it has the effect of
setting the setup variable\newline \code{parallelIO = False}\tr

\tabopt{\code{+parallelIO} }%\index{setup!parallelIO@\code{parallelIO}}} %
& This shortcut specifies a simulation using serial IO, it has the effect of
setting the setup variable\newline \code{parallelIO = True}\tr

\tabopt{\code{+hdf5} }%\index{setup!hdf5@\code{hdf5}}} %
& This shortcut specifies a simulation using hdf5 for compatible binary IO output, it has the effect of
setting the setup variable\newline \code{IO = hdf5}\tr


\tabopt{\code{+hdf5TypeIO} }%\index{setup!hdf5TypeIO@\code{hdf5TypeIO}}} %
& This shortcut specifies a simulation using hdf5, with parallel io capability
 for compatible binary IO output, and is equivalent to the following:\newline
 \code{+io +parallelIO +hdf5 typeIO=True}\tr


\tabopt{\code{+nolog} }%\index{setup!nolog@\code{nolog}}} %
& This shortcut specifies a simulation without log capability it is equivalent
to the following:\newline \code{-without-unit=monitors/Logfile}\tr

\tabopt{\code{+grid} }%\index{setup!grid@\code{grid}}} %
& This shortcut specifies a simulation with the Grid unit, it is equivalent
to the following:\newline \code{-unit=Grid}\tr

\tabopt{\code{+ug} }%\index{setup!ug@\code{ug}}} %
& This shortcut specifies a simulation using a uniform grid, it is equivalent
to the following:\newline \code{+grid Grid=UG}\tr

\tabopt{\code{+pm2} }%\index{setup!pm2@\code{pm2}}} %
& This shortcut specifies a simulation using Paramesh2 for the grid, it is equivalent
to the following:\newline \code{+grid Grid=PM2}\tr

\tabopt{\code{+pm40} }%\index{setup!pm40@\code{pm40}}} %
& This shortcut specifies a simulation using Paramesh4.0 for the grid, it is equivalent
to the following:\newline \code{+grid Grid=PM40}\tr

\tabopt{\code{+pm4dev_clean} }%\index{setup!pm4dev_clean@\code{pm4dev_clean}}} %
& This shortcut specifies a simulation using a version of Paramesh 4 that is closer
to the version available on sourceforge. It is equivalent to:\newline
\code{+grid Grid=PM4DEV ParameshLibraryMode=True}\tr

\tabopt{\code{+pm4dev} }%\index{setup!pm4dev@\code{pm4dev}}} %
& This shortcut specifies a simulation using a modified version of Paramesh 4 that
includes a more scalable way of filling the \code{surr\_blks} array. It is equivalent to:\newline
\code{+pm4dev_clean FlashAvoidOrrery=True}\tr

\tabopt{\code{+usm} }%\index{setup!usm@\code{usm}}} %
& This shortcut specifies a MHD simulation using the unsplit staggered mesh hydro solver, if
pure hydro mode is used with the USM solver add +pureHydro in the setup line. It is equivalent to:\newline
\code{--with-unit=physics/Hydro/HydroMain/unsplit/MHD_StaggeredMesh --without-unit=physics/Hydro/HydroMain/split/MHD_8Wave}\tr

\tabopt{\code{+pureHydro} }%\index{setup!pureHydro@\code{pureHydro}}} %
& This shortcut specifies using pure hydro mode, it is equivalent to:\newline
\code{physicsMode=hydro}\tr

\tabopt{\code{+splitHydro} }%\index{setup!splitHydro@\code{splitHydro}}} %
& This shortcut specifies a simulation using a split hydro solver and is equivalent to:\newline
\code{--unit=physics/Hydro/HydroMain/split -without-unit=physics/Hydro/HydroMain/unsplit SplitDriver=True}\tr

\tabopt{\code{+unsplitHydro} }%\index{setup!unsplitHydro@\code{unsplitHydro}}} %
& This shortcut specifies a simulation using the unsplit hydro solver and is equivalent to:\newline
\code{--with-unit=physics/Hydro/HydroMain/unsplit/Hydro_Unsplit}\tr

\tabopt{\code{+uhd} }%\index{setup!uhd@\code{uhd}}} %
& This shortcut specifies a simulation using the unsplit hydro solver and is equivalent to:\newline
\code{--with-unit=physics/Hydro/HydroMain/unsplit/Hydro_Unsplit}\tr

\tabopt{\code{+supportPPMUpwind} }%\index{setup!supportPPMUpwind@\code{supportPPMUpwind}}} %
& This shortcut specifies a simulation using a specific Hydro method that
requires an increased number of guard cells, this may need to be combined with
 \code{-nxb=... -nyb=... etc.} where the specified blocksize is greater than or
equal to 12 (==2*GUARDCELLS). It is equivalent to:\newline
\code{SupportPpmUpwind=True}\tr

\tabopt{\code{+cube64} }%\index{setup!cube64@\code{cube64}}} %
& This shortcut specifies a simulation with a block size of 64**3, it is equivalent to:\newline
\code{-nxb=64 -nyb=64 -nzb=64}\tr

\tabopt{\code{+cube32} }%\index{setup!cube32@\code{cube32}}} %
& This shortcut specifies a simulation with a block size of 32**3, it is equivalent to:\newline
\code{-nxb=32 -nyb=32 -nzb=32}\tr

\tabopt{\code{+cube16} }%\index{setup!cube16@\code{cube16}}} %
& This shortcut specifies a simulation with a block size of 16**3, it is equivalent to:\newline
\code{-nxb=16 -nyb=16 -nzb=16}\tr

\tabopt{\code{+ptio} }%\index{setup!ptio@\code{ptio}}} %
& This shortcut specifies a simulation using particles and IO for uniform grid,
it is equivalent to: \newline \code{+ug -with-unit=Particles}\tr

\tabopt{\code{+rnf} }%\index{setup!rnf@\code{rnf}}} %
& This shortcut is used for checking Flash-X with rectangular block sizes and non-fixed block size.
It is equivalent to:\newline \code{-3d -nxb=8 -nyb=16 -nzb=32 -nofbs +ug}\tr

\tabopt{\code{+nofbs} }%\index{setup!nofbs@\code{nofbs}}} %
& This shortcut specifies a simulation using a uniform grid with a non-fixed block size.
It is equivalent to:\newline \code{-nofbs +ug parallelIO=True}\tr

\tabopt{\code{+curvilinear} }%\index{setup!curvilinear@\code{curvilinear}}} %
& This shortcut specifies a simulation using curvilinear geometry. It is equivalent
to:\newline \code{-curvilinear}\tr

\tabopt{\code{+cartesian} }%\index{setup!cartesian@\code{cartesian}}} %
& This shortcut specifies a simulation using cartesian geometry. It is equivalent
to:\newline \code{-geometry=cartesian}\tr

\tabopt{\code{+spherical} }%\index{setup!spherical@\code{spherical}}} %
& This shortcut specifies a simulation using spherical geometry. It is equivalent
to:\newline \code{-geometry=spherical}\tr

\tabopt{\code{+polar} }%\index{setup!polar@\code{polar}}} %
& This shortcut specifies a simulation using polar geometry. It is equivalent
to:\newline \code{-geometry=polar}\tr

\tabopt{\code{+cylindrical} }%\index{setup!cylindrical@\code{cylindrical}}} %
& This shortcut specifies a simulation using cylindrical geometry. It is equivalent
to:\newline \code{-geometry=cylindrical}\tr

\tabopt{\code{+ptdens} }%\index{setup!ptdens@\code{ptdens}}} %
& This shortcut specifies a simulation using passive particles initialized by density.
It is equivalent to:\newline
\code{-without-unit=Particles/ParticlesInitialization/Lattice}\newline
 \code{-without-unit=Particles/ParticlesInitialization/WithDensity/CellMassBins}\newline
 \code{-unit=Particles/ParticlesMain}\newline
 \code{-unit=Particles/ParticlesInitialization/WithDensity}\newline
 \code{-particlemethods=TYPE=passive,INIT=With_Density}\tr

\tabopt{\code{+npg} }%\index{setup!npg@\code{npg}}} %
& This shortcut specifies a simulation using NO_PERMANENT_GUARDCELLS mode in Paramesh4.
It is equivalent to:\newline \code{npg=True}\tr

\tabopt{\code{+mpole} }%\index{setup!mpole@\code{mpole}}} %
& This shortcut specifies a smilulation using multipole gravity, it is
equivalent to:\newline \code{-with-unit=physics/Gravity/GravityMain/Poisson/Multipole}\tr

\tabopt{\code{+longrange} }%\index{setup!longrange@\code{longrange}}} %
& This shortcut specifies a simulation using long range active particles. It is 
equivalent to:\newline \code{-with-unit=Particles/ParticlesMain/active/longRange/gravity/ParticleMesh}\tr

\tabopt{\code{+gravPfftNofbs} }%\index{setup!gravPfftNofbs@\code{gravPfftNofbs}}} %
& This shortcut specifies a simulation using FFT based gravity solve on a uniform grid
with no fixed block size. It is equivalent to:\newline 
\code{+ug +nofbs -with-unit=physics/Gravity/GravityMain/Poisson/Pfft}\tr

\tabopt{\code{+gravMgrid} }%\index{setup!gravMgrid@\code{gravMgrid}}} %
& This shortcut specifies a simulation using a multigrid based gravity solve. It is equivalent to:\newline
\code{+pm40 -with-unit=physics/Gravity/GravityMain/Poisson/Multigrid}\tr

\tabopt{\code{+gravMpole} }%\index{setup!gravMpole@\code{gravMpole}}} %
& This shortcut specifies a smilulation using multipole gravity, it is
equivalent to:\newline \code{-with-unit=physics/Gravity/GravityMain/Poisson/Multipole}\tr

\tabopt{\code{+noDefaultMpole} }%\index{setup!noDefaultMpole@\code{noDefaultMpole}}} %
& This shortcut specifies a simulation *not* using the multipole based gravity solve.
It is equivalent to:\newline \code{-without-unit=Grid/GridSolvers/Multipole}\tr

\tabopt{\code{+noMgrid} }%\index{setup!noMgrid@\code{noMgrid}}} %
& This shortcut specifies a simulation *not* using the multigrid based gravity solve.
It is equivalent to:\newline \code{-without-unit=physics/Gravity/GravityMain/Poisson/Multigrid}\tr

\tabopt{\code{+newMpole} }%\index{setup!newMpole@\code{newMpole}}} %
& This shortcut specifies a simulation using the new multipole based gravity solve.
It is equivalent to:\newline \code{+noMgrid +noDefaultMpole +gravMpole -with-unit=Grid/GridSolvers/Multipole_new}\tr

\tabopt{\code{+pic} }%\index{setup!pic@\code{pic}}} %
& This shortcut specifies use of proper particle units to perform PIC (particle in cell) method. It is equivalent to:\newline
\code{+ug -unit=Grid/GridParticles/GridParticlesMove}\newline
 \code{-without-unit=Grid/GridParticles/GridParticlesMove/UG}\newline
 \code{-without-unit=Grid/GridParticles/GridParticlesMove/UG/Directional}\tr

\tabopt{\code{Grid} }%\index{setup!Grid@\code{Grid}}} %
& This setup variable can be used to specify which gridding package to use in a simulation:\newline
Name: \code{Grid}\newline
Type: \code{String}\newline
Values: \code{PM4DEV}, \code{PM40}, \code{UG}\tr

\tabopt{\code{IO} }%\index{setup!IO@\code{IO}}} %
& This setup variable can be used to specify which IO  package to use in a simulation:\newline
Name: \code{IO}\newline
Type: \code{String}\newline
Values: \code{hdf5, pnetcdf, MPIHybrid, MPIDump, direct}\tr

\tabopt{\code{parallelIO} }%\index{setup!parallelIO@\code{parallelIO}}} %
& This setup variable can be used to specify which type of IO strategy will be used.
A ``parallel'' strategy will be used if the value is true, a ``serial'' strategy otherwise.\newline
Name: \code{parallelIO}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{fixedBlockSize} }%\index{setup!fixedBlockSize@\code{fixedBlockSize}}} %
& This setup variable indicates whether or not a fixed block size is to be used.
This variable should not be assigned explicitly on the command line.
It defaults to \code{True}, and
the setup options \code{-nofbs} and \code{-fbs} modify the value of this variable.\newline
Name: \code{fixedBlockSize}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{nDim} }%\index{setup!nDim@\code{nDim}}} %
& This setup variable gives the dimensionality of a simulation. 
This variable should not be set explicitly on the command line, it
is automatically set by the setup options \code{-1d}, \code{-2d}, and \code{-3d}.\newline
Name: \code{nDim}\newline
Type: \code{integer}\newline
Values: \code{1,2,3}\tr

\tabopt{\code{GridIndexOrder} }%\index{setup!GridIndexOrder@\code{GridIndexOrder}}} %
& This setup variable indicates whether the \code{-index-reorder} setup option is in effect.
This variable should not be assigned explicitly on the command line.\newline
Name: \code{GridIndexOrder}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{nxb} }%\index{setup!nxb@\code{nxb}}} %
& This setup variable gives the number of zones in a block in the X direction.
This variable should not be assigned explicitly on the command line, it
is automatically set by the setup option \code{-nxb}.\newline
Name: \code{nxb}\newline
Type: \code{integer}\tr

\tabopt{\code{nyb} }%\index{setup!nyb@\code{nyb}}} %
& This setup variable gives the number of zones in a block in the Y direction.
This variable should not be assigned explicitly on the command line, it
is automatically set by the setup option \code{-nyb}.\newline
Name: \code{nyb}\newline
Type: \code{integer}\tr

\tabopt{\code{nzb} }%\index{setup!nzb@\code{nzb}}} %
& This setup variable gives the number of zones in a block in the Z direction.
This variable should not be assigned explicitly on the command line, it
is automatically set by the setup option \code{-nzb}.\newline
Name: \code{nzb}\newline
Type: \code{integer}\tr

\tabopt{\code{maxBlocks} }%\index{setup!maxBlocks@\code{maxBlocks}}} %
& This setup variable gives the maximum number of blocks per processor.
This variable should not be assigned explicitly on the command line, it
is automatically set by the setup option \code{-maxblocks}.\newline 
Name: \code{maxBlocks}\newline
Type: \code{integer}\tr

\tabopt{\code{ParameshLibraryMode} }%\index{setup!ParameshLibraryMode@\code{ParameshLibraryMode}}} %
& If true, the setup script will generate file
\code{amr\_runtime\_parameters} from template \code{amr\_runtime\_parameters.tpl}
found in either the object directory (preferred) or the
setup script (bin) directory. Selects whether Paramesh4 should be compiled in LIBRARY mode,
i.e., with the preprocessor symbol LIBRARY defined.\newline
Name: \code{ParameshLibraryMode}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{PfftSolver} }%\index{setup!PfftSolver@\code{PfftSolver}}} %
& PfftSolver selects a PFFT solver variant when the hybrid
  (\ie, Multigrid with PFFT) Poisson solver is used.\newline
Name: \code{PfftSolver}\newline
Type: \code{String}\newline
Values: \code{DirectSolver} (default), \code{HomBcTrigSolver}, others (unsupported) if
        recognized in \code{source/Grid/GridSolvers/Multigrid/PfftTopLevelSolve/Config} \tr

\tabopt{\code{SplitDriver} }%\index{setup!SplitDriver@\code{SplitDriver}}} %
& If True, a \code{Split} \unit{Driver} implementation is requested.\newline
Name: \code{SplitDriver}\newline
Type: \code{Boolean}\tr

\tabopt{\code{Mtmmmt} }%\index{setup!Mtmmmt@\code{Mtmmmt}}} %
& Automatically set \code{True} by \code{+mtmmmt} shortcut. When true, this option activates the MTMMMT EOS.\newline
Name: \code{Mtmmmt}\newline
Type: \code{Boolean}\tr

\tabopt{\code{mgd_meshgroups} }%\index{setup!mgd_meshgroups@\code{mgd_meshgroups}}} %
& mgd_meshgroups * meshCopyCount sets the MAXIMUM number of radiation
groups that can be used in a simulation. The ACTUAL number of groups
(which must be less than mgd_meshgroups * meshCopyCount) is set by
the rt_mgdNumGroups runtime parameter.\newline
Name: \code{mgd_meshgroups}\newline
Type: \code{Integer}\tr

\tabopt{\code{species} }%\index{setup!species@\code{species}}} %
& This setup variable can be used as an alternative specifying species
using the SPECIES Config file directive by listing the species in
the setup command. Some units, like the Multispecies Opacity unit,
will ONLY work when the species setup variable is set. This is
because they use the species name to automatically create runtime
paramters which include the species names.\newline
Name: \code{species}\newline
Type: \code{String}, comma seperated list of strings (\eg, \code{species=air,sf6)}\tr

\tabopt{\code{ed_maxPulses} }%\index{setup!ed_maxPulses@\code{ed_maxPulses}}} %
&
\newline
Name: \code{ed_maxPulses}\newline
Type: \code{integer}\newline
Remark: Maximum number of laser pulses (defaults to 5)\tr

\tabopt{\code{ed_maxBeams} }%\index{setup!ed_maxBeams@\code{ed_maxBeams}}} %
&
\newline
Name: \code{ed_maxBeams}\newline
Type: \code{integer}\newline
Remark: Maximum number of laser beams (defaults to 6)\tr

\tabopt{\code{threadHydroBlockList} }%\index{setup!threadHydroBlockList@\code{threadHydroBlockList}}} %
& This is used to turn on block list OPENMP threading of hydro routines.\newline
Name: \code{threadHydroBlockList}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{threadMpoleBlockList} }%\index{setup!threadMpoleBlockList@\code{threadMpoleBlockList}}} %
& This is used to turn on block list OPENMP threading of the multipole routine.\newline
Name: \code{threadMpoleBlockList}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{threadRayTrace} }%\index{setup!threadRayTrace@\code{threadRayTrace}}} %
& This is used to turn on block list OPENMP threading of Enery Deposition source term routines.\newline
Name: \code{threadRayTrace}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{threadHydroWithinBlock} }%\index{setup!threadHydroWithinBlock@\code{threadHydroWithinBlock}}} %
& This is used to turn on within block OPENMP threading of hydro routines.\newline
Name: \code{threadHydroWithinBlock}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{threadEosWithinBlock} }%\index{setup!threadEosWithinBlock@\code{threadEosWithinBlock}}} %
& This is used to turn on within block OPENMP threading of Eos routines.\newline
Name: \code{threadEosWithinBlock}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\tabopt{\code{threadMpoleWithinBlock} }%\index{setup!threadMpoleWithinBlock@\code{threadMpoleWithinBlock}}} %
& This is used to turn on within block OPENMP threading of then multipole routine.\newline
Name: \code{threadMpoleWithinBlock}\newline
Type: \code{Boolean}\newline
Values: \code{True, False}\tr

\end{longtable}

% \begin{flashtip}[Dependencies among libraries]
% If you have some libraries which depend on other libraries, create a
% \code{lib/<libname>/Config} which declares the dependencies.
% Libraries can have their own \code{Config} files, but the format is
% a little different. For details see
% \weblink{\makeHowtoURL{Library-HOWTO}}{Library-HOWTO}.
% \end{flashtip}

\section{Using Shortcuts}\label{Sec:SetupShortcuts}
Apart from the various setup options the \setup script also allows
you to use shortcuts for frequently used combinations of options.
For example, instead of typing in
\begin{codeseg}
 ./setup -a Sod -with-unit=Grid/GridMain/UG
\end{codeseg}
\noindent you can just type
\begin{codeseg}
./setup -a Sod +ug
\end{codeseg}

The \code{+ug} or any setup option starting with a `+' is
considered as a shortcut. By default, setup looks at
\code{bin/setup\_shortcuts.txt} for a list of declared shortcuts.
You can also specify a ":" delimited list of files in the
environment variable \code{SETUP\_SHORTCUTS} and \setup will read
all the files specified (and ignore those which don't exist) for
shortcut declarations. See \figref{Fig:ShortcutFile} for an example
file.

\begin{figure}[htbp]
%%\begin{center}
\begin{fcodeseg}
 # comment line

 # each line is of the form # shortcut:arg1:arg2:...:
 # These shortcuts can refer to each other.

 default:--with-library=mpi:-unit=IO/IOMain:-gridinterpolation=monotonic

 # io choices
 noio:--without-unit=IO/IOMain:
 io:--with-unit=IO/IOMain:

 # Choice of Grid
 ug:-unit=Grid/GridMain/UG:
 pm2:-unit=Grid/GridMain/paramesh/Paramesh2:
 pm40:-unit=Grid/GridMain/paramesh/paramesh4/Paramesh4.0:
 pm4dev:-unit=Grid/GridMain/paramesh/paramesh4/Paramesh4dev:

 # frequently used geometries
 cube64:-nxb=64:-nyb=64:-nzb=64:
\end{fcodeseg}
%%\end{center}
\caption{A sample \code{setup\_shortcuts.txt} file\label{Fig:ShortcutFile}}
\end{figure}

The shortcuts are replaced by their expansions in place, so options
which come after the shortcut override (or conflict with) options
implied by the shortcut. A shortcut can also refer to other
shortcuts as long as there are no cyclic references.

The ``default"%\index{setup!+default}
shortcut is special. \setup
always prepends \code{+default} to its command line thus making
\code{./setup -a Sod} equivalent to \code{./setup +default -a Sod}.
Thus changing the default IO to ``hdf5/parallel", is as simple as
changing the definition of the ``default" shortcut.

Some of the more commonly used shortcuts are described below:

\begin{table}
\caption{ \label{Tab:setup_shortcuts} Shortcuts for often-used options}
\begin{center}
\begin{tabular}{ll}
\hline
Shortcut & Description\\
\hline
\grayrow 	+cartesian 	& 	use cartesian geometry\\
		+cylindrical	&	use cylindrical geometry\\
\grayrow	+noio		&	omit IO\\
		+nolog		&	omit logging\\
\grayrow	+pm4dev		&	use the PARAMESH4DEV grid\\
	        +polar		&	use polar geometry\\
\grayrow	+spherical	&	use spherical geometry\\
                +ug		&	use the uniform grid in a fixed block size mode\\
\grayrow	+nofbs		&	use the uniform grid in a non-fixed block size mode\\
                +usm		&	use the Unsplit Staggered Mesh MHD solver\\
\grayrow	+8wave		&	use the 8-wave MHD solver\\
                +splitHydro	&	use a split Hydro solver\\
\hline
\end{tabular}
\end{center}
\end{table}


\begin{table}
\caption{ \label{Tab:setup_shortcuts_hedp} Shortcuts for HEDP options}
\begin{center}
\begin{tabular}{ll}
\hline
Shortcut & Description\\
\hline
\grayrow 	+mtmmmt & Use the 3-T, multimaterial, multitype EOS \\
		+uhd3t	& Use the 3-T version of Unsplit Hydro \\
\grayrow 	+usm3t  & Use the 3-T version of Unsplit Staggered Mesh MHD \\
                +mgd    & Use Multigroup Radiation Diffusion and Opacities \\
\grayrow        +laser  & Use the Laser Ray Trace package \\
\hline
\end{tabular}
\end{center}
\end{table}


\section{Setup Variables and Preprocessing \code{Config} Files}
\label{Sec:setupvariables}

\setup allows you to assign values to ``Setup Variables''. These
variables can be string-valued, integer-valued, or boolean. A \code{setup}
call like

\begin{codeseg}
./setup -a Sod Foo=Bar Baz=True
\end{codeseg}

\noindent sets the variable ``Foo" to string ``Bar" and ``Baz" to boolean 
True\footnote{All non-integral values not equal to
True/False/Yes/No/On/Off are considered to be string values}.
\setup can conditionally include and exclude parts of the
\code{Config} file it reads based on the values of these variables.
For example, the \code{IO/IOMain/hdf5/Config} file contains

\begin{figure}[h]
\begin{shrink}
%%\begin{center}
\begin{fcodeseg}
 DEFAULT serial

 USESETUPVARS parallelIO

 IF parallelIO
    DEFAULT parallel
 ENDIF
\end{fcodeseg}
\end{shrink}
%%\end{center}
\end{figure}

The code sets IO to its default value of ``serial'' and then resets
it to ``parallel" if the setup variable ``parallelIO" is True. The
\code{USESETUPVARS} keyword in the \code{Config} file instructs setup
that the specified variables must be defined; undefined variables
will be set to the empty string. 

Through judicious use of setup
variables, the user can ensure that specific implementations are included
or the simulation is properly configured.
For example, the setup line \code{./setup -a Sod +ug}
expands to \code{./setup -a Sod -unit=Grid/GridMain/ Grid=UG}.
The relevant part of the \code{Grid/GridMain/Config} file is given below:
%%\begin{figure}[h]
\begin{shrink}
\begin{fcodeseg}
# Requires use of the Grid SetupVariable
USESETUPVARS Grid

DEFAULT paramesh

IF Grid=='UG'
   DEFAULT UG
ENDIF
IF Grid=='PM2'
   DEFAULT paramesh/Paramesh2
ENDIF
\end{fcodeseg}
\end{shrink}
%%\caption{An excerpt from \code{Grid/GridMain/Config}}
%%\end{figure}
The \code{Grid/GridMain/Config} file defaults to choosing \Paramesh. But
when the setup variable Grid is set to ``UG" through the shortcut \code{+ug}, 
the default implementation is set to ``UG". The
same technique is used to ensure that the right IO unit is automatically
included.

See \code{bin/Readme.SetupVars} for an exhaustive list of Setup Variables
which are used in the various Config files.  For example the setup variable 
\code{nDim} can be test to ensure that a simulation is configured with the appropriate
dimensionality (see for example \code{Simulation/SimulationMain/unitTest/Eos/Config}).

\section{\code{Config} Files}
\label{Sec:Config}
% \begin{comment}
% \begin{shrink}
% \begin{codeseg}
% 
% #       Configuration file for the Sod shock-tube problem
% #       (Sod, G. A., 1978, J. Comp. Phys., 27, 1)
% 
% REQUIRES Driver
% REQUIRES physics/Hydro
% REQUIRES physics/Eos
% 
% 
% D sim_rhoLeft Density in the left part of the grid
% PARAMETER sim_rhoLeft   REAL    1.       [0 to ]
% 
% D sim_rhoRight Density in the right part of the grid
% PARAMETER sim_rhoRight  REAL    0.125    [0 to ]
% 
% D sim_pLeft Pressure  in the left part of the grid
% PARAMETER sim_pLeft     REAL    1.       [0 to ]
% 
% D sim_pRight Pressure  in the right part of the grid
% PARAMETER sim_pRight    REAL    0.1      [0 to ]
% 
% D sim_uLeft fluid velocity in the left part of the grid
% PARAMETER sim_uLeft     REAL    0.
% 
% \end{codeseg}
% \end{shrink}
% \end{comment}
Information about unit dependencies, default sub-units, runtime
parameter definitions, library requirements, and physical variables, etc. 
is contained in plain text files named \code{Config} in the different unit
directories. These are parsed by \code{setup} when configuring the
source tree and are used to create the code needed to register unit
variables, to implement the runtime parameters, to choose specific
sub-units when only a generic unit has been specified, to prevent
mutually exclusive units from being included together, and to flag
problems when dependencies are not resolved by some included
unit. Some of the Config files contain additional information about
unit interrelationships. As mentioned earlier, \code{setup} starts
from the \code{Config} file in the Simulation directory of the problem
being built.

\subsection{Configuration file syntax}\label{Sec:ConfigFileSyntax}

Configuration files come in two syntactic flavors: static text and python.
In static mode, configuration directives are listed as lines in a plain text
file.  This mode is the most readable and intuitive of the two, but it lacks
flexibility.  The python mode has been introduced to circumvent this
inflexibility by allowing the configuration file author to specify the
configuration directives as a function of the setup variables with a python
procedure.  This allows the content of each directive and the number of
directives in total to be amenable to general programming.

The rule the setup script uses for deciding which flavor of configuration
file it's dealing with is simple.  Python configuration files have as their
first line \code{\#\#python:genLines}.  If the first line does not match
this string, then static mode is assumed and each line of the file is
interpreted verbatim as a directive.

If python mode is triggered, then the entire file is considered as valid
python source code (as if it were a .py).  From this python code, a
function of the form \code{def genLines(setupvars)} is located and
executed to generate the configuration directives as an array (or any
iterable collection) of strings.  The sole argument to genLines is a
dictionary that maps setup variable names to their corresponding string
values.

As an example, here is a configuration file in python mode that registers
runtime parameters named indexed_parameter_x where x ranges from 1 to NP
and NP is a setup line variable.

\begin{fcodeseg}
##python:genLines

# We define genLines as a generator with the very friendly "yield" syntax.
# Alternatively, we could have genLines return an array of strings or even
# one huge multiline string.
def genLines(setupvars):
    # emit some directives that dont depend on any setup variables
    yield """
REQUIRES Driver
REQUIRES physics/Hydro
REQUIRES physics/Eos
"""
    # read a setup variable value from the dictionary
    np = int(setupvars("NP")) # must be converted from a string
    # loop from 0 to np-1
    for x in xrange(np):
        yield "PARAMETER indexed_parameter_\%d REAL 0." \% (x+1)
\end{fcodeseg}

When setting up a problem with NP=5 on the setup command line, the
following directives will be processed:
\begin{fcodeseg}
REQUIRES Driver
REQUIRES physics/Hydro
REQUIRES physics/Eos
PARAMETER indexed_parameter_1 REAL 0.
PARAMETER indexed_parameter_2 REAL 0.
PARAMETER indexed_parameter_3 REAL 0.
PARAMETER indexed_parameter_4 REAL 0.
PARAMETER indexed_parameter_5 REAL 0.
\end{fcodeseg}

\subsection{Configuration directives}\label{Sec:ConfigDirectives}
The syntax of the configuration directives is described here. Arbitrarily
many spaces and/or tabs may be used, but all keywords must be in uppercase.
Lines not matching an admissible pattern will raise an error when running
setup.

\begin{itemize}

\item \code{\# comment}\\
A comment. Can appear as a separate line or at the end of a line.

\item \code{DEFAULT} \metavar{sub-unit}\\
Every unit and sub-unit designates one implementation to be the
``default'', as defined by the keyword \code{DEFAULT} in its
\code{Config} file. If no specific implementation of the unit or its
sub-units is selected by the application, the designated default
implementation gets included. For example, the \code{Config} file for
the \code{EosMain} specifies Gamma as the default. If no specific
implementation is explicitly included (\ie, \code{INCLUDE
physics/Eos/EosMain/Multigamma}), then this command instructs \code{setup} to
include the Gamma implementation, as though \code{INCLUDE
physics/Eos/EosMain/Gamma} had been placed in the \code{Units} file.

\item \code{EXCLUSIVE} \metavar{implementation...}\\
Specifies a list of implementations that cannot be included together. If no
\code{EXCLUSIVE} instruction is given, it is perfectly legal to
simultaneously include more than one implementation in the code. Using
``\code{EXCLUSIVE} *'' means that at most one implementation can be
included.

\item \code{CONFLICTS} \metavar{unit1[/sub-unit[/implementation...]]} ... \\
Specifies that the current unit, sub-unit, or specific implementation
is not compatible with the list of units, sub-units or other
implementations that follows. \setup issues an error if the user
attempts a conflicting unit configuration.


\item \code{REQUIRES} \metavar{unit[/sub-unit[/implementation...]]  [}
\code{OR} \metavar{unit[/sub-unit...]]...}\\
Specifies a unit requirement. Unit requirements can be general, without
asking for a specific implementation, so that unit dependencies are not
tied to particular algorithms. For example, the statement
\code{REQUIRES physics/Eos} in a unit's \code{Config} file indicates to
\code{setup} that the physics/Eos unit is needed, but no particular equation
of state is specified. As long as an \code{Eos} implementation is included, 
the dependency will be satisfied. More specific dependencies can be
indicated by explicitly asking for an implementation. For example, if
there are multiple species in a simulation, the \code{Multigamma} equation
of state is the only valid option. To ask for it explicitly, use
\code{REQUIRES physics/Eos/EosMain/Multigamma}. Giving a complete set of unit
requirements is helpful, because \code{setup} uses them to generate the units
file when invoked with the -auto option.

\item \code{REQUESTS} \metavar{unit[/sub-unit[/implementation...]]}\\
Requests that a unit be added to the Simulation. All requests are upgraded
to a ``REQUIRES'' if they are not negated by a "-without-unit" option from the
command line. If negated, the \code{REQUEST} is ignored. This can be used to
turn off profilers and other ``optional'' units which are included by default.

\item \code{SUGGEST} \metavar{unitname unitname ...}\\
Unlike \code{REQUIRES}, this keyword suggests that the current unit be
used along with one of the specified units. The setup script will
print details of the suggestions which have been ignored. This is
useful in catching inadvertently omitted units before the run starts,
thus avoiding a waste of computing resources.



\item \code{PARAMETER} \metavar{name type [\code{CONSTANT}] default}
  [\metavar{range-spec}] \\
Specifies a runtime parameter. Parameter names are unique up to 20 characters and
may not contain spaces. Admissible types include \code{REAL}, \code{INTEGER},
\code{STRING}, and \code{BOOLEAN}.  Default values for \code{REAL} and \code{INTEGER}
parameters must be valid numbers, or the compilation will fail. Default
\code{STRING} values must be enclosed in double quotes (\code{"}).
Default \code{BOOLEAN} values must be \code{.true.} or \code{.false.} to
avoid compilation errors. Once defined, runtime parameters are available to the
entire code. Optionally, any parameter may be specified with the \code{CONSTANT}
attribute (\eg, \code{PARAMETER foo REAL CONSTANT 2.2}).
If a user attempts to set a constant parameter via the runtime parameter file,
an error will occur.

The range specification is optional and can be used to specify valid ranges
for the parameters. The range specification is allowed only for \code{REAL,
INTEGER, STRING} variables and must be enclosed in '[]'.

For a \code{STRING} variable, the range specification is a comma-separated
list of strings (enclosed in quotes). For a \code{INTEGER, REAL} variable,
the range specification is a comma-separated list of (closed) intervals
specified by \code{min ... max}, where min and max are the end points of
the interval. If min or max is omitted, it is assumed to be $-\infty$
and $+\infty$ respectively. Finally \code{val} is a shortcut for
\code{val ... val}. For example
\begin{codeseg}
PARAMETER pres REAL 1.0 [ 0.1 ... 9.9, 25.0 ... ]
PARAMETER coords STRING "polar" ["polar","cylindrical","2d","3d"]
\end{codeseg}

indicates that \code{pres} is a REAL variable which is allowed to take
values between 0.1 and 9.9 or above 25.0. Similarly \code{coords}
is a string variable which can take one of the four specified values.

\item \code{D} \metavar{parameter-name} \metavar{comment}\\
Any line in a \code{Config} file is considered a parameter comment
line if it begins with the token \code{D}. The first token after the
comment line is taken to be the parameter name. The remaining tokens
are taken to be a description of the parameter's purpose. A token is
delineated by one or more white spaces. For example,
\begin{codeseg}
D SOME_PARAMETER The purpose of this parameter is whatever
\end{codeseg} 
If the parameter comment requires additional lines, the \texttt{\&}
is used to indicate continuation lines. For example,
\begin{codeseg}
D SOME_PARAMETER The purpose of this parameter is whatever
D &              This is a second line of description
\end{codeseg}

You can also use this to describe other variables, fluxes, species, etc.
For example, to describe a species called "xyz", create a comment
for the parameter ``xyz\_species''. In general the name should be followed by
an underscore and then by the lower case name of the keyword used to define the
name.

Parameter comment lines are special because they are used by
\setup to build a formatted list of commented runtime parameters
for a particular problem. This information is generated
in the file \code{setup\_params} in the \code{object} directory.


\item \code{VARIABLE} \metavar{name} \metavar{[\code{TYPE:} vartype]}
\metavar{[eosmap-spec]}\\
Registers variable
with the framework with name \metavar{name} and a variable type%\index{variable type}
 defined by
\metavar{vartype}. The \code{setup} script collects variables
from all the included units, and creates a comprehensive list with no
duplications. It then assigns defined constants to each variable and
calculates the amount of storage required in the data structures for
storing these variables. The defined constants and the calculated sizes
are written to the file \code{Flash.h}.

The possible types for \metavar{vartype} are as follows:
\begin{itemize}
\item \code{PER\_VOLUME}\\
This solution variable is represented in
\emterm{conserved}%\index{variable!type!conserved}
form,
\ie, it represents the density of a conserved extensive quantity.
The prime example is a variable directly representing mass density.
Energy densities, momentum densities, and partial mass densities
would be other examples (but these quantities are usually represented in
\code{PER\_MASS} form instead).
\item \code{PER_MASS}\\
This solution variable is represented in
\emterm{mass-specific}%\index{variable!type!mass-specific}
form,
\ie, it represents quantities whose nature is
$\hbox{extensive quantity}\,\mathop{\mathrm{per}}\,\hbox{mass unit}$.
Examples are specific energies, velocities of material (since
they are equal to momentum per mass unit), and abundances
or mass fractions (partial density divided by density).
\item \code{GENERIC}\\
This is the default \metavar{vartype} and need not be specified.
This type should be used for any variables that do not clearly belong
to one of the previous two categories.
\begin{comment}
\item \code{ADVECT/NOADVECT}\\
A variable $Q$ with the \code{ADVECT} property obeys an advection equation,
\begin{equation}
\frac{\partial Q}{\partial t} + {\bf \nabla} \cdot (Q {\bf v}) = 0~.
\end{equation}
\item \code{RENORM/NORENORM}\\
Variables $\{Q_i\}$ marked with the \code{RENORM} property obey the constraint
\begin{equation}
\sum_i Q_i = 1~.
\end{equation}
\item \code{CONSERVE/NOCONSERVE}\\
Variables marked with the \code{CONSERVE} property obey conservation laws
(\eg, momentum vs. velocity).
\end{comment}
\end{itemize}
In the current version of the
code, the \code{TYPE} attribute is only used to determine
which variables should be converted to conservative form
for certain \unit{Grid} operations that may require
interpolation (\ie, prolongation, guardcell filling, and restriction)
when one of the runtime parameters
\newline  % prevent overflow
\rpi{Grid/convert\-To\-Consvd\-For\-Mesh\-Calls} or
\rpi{Grid/convert\-To\-Consvd\-In\-Mesh\-Interp} is set \code{true}.
Only variables of type \code{PER_MASS} are converted: values
are multiplied cell-by-cell with the value of the \code{"dens"}
variable, and potential interpolation results are converted
back by cell-by-cell division by \code{"dens"} values after
interpolation.

Note that therefore
\begin{itemize}
\item variable types are irrelevant for uniform grids,
\item variable types are irrelevant if
neither \rpi{Grid/convertToConsvdForMeshCalls} nor
\newline  % prevent overfull
\rpi{Grid/convertToConsvdInMeshInterp} is \code{true}, and
\item variable types (and conversion to and from conserved form)
only take effect if a \begin{codeseg}
VARIABLE dens ...
\end{codeseg}
exists.
\end{itemize}

An \metavar{eosmap-spec} has the syntax
\metavar{ \code{EOSMAP:} eos-role} $|$ \metavar{( [\code{EOSMAPIN:} eos-role] [\code{EOSMAPOUT:} eos-role ])},
where \metavar{eos-role} stands for a \emterm{role} as defined in \code{Eos\_map.h}.
These roles are used within implementations of the \api{physics/Eos/Eos_wrapped} interface,
via the subroutines \api{physics/Eos/Eos_getData} and \api{physics/Eos/Eos_putData},
to map variables from \unit{Grid} data structures to the \code{eosData} array
that \api{physics/Eos/Eos} understands, and back.
For example,
\begin{codeseg}
VARIABLE eint TYPE: PER_MASS EOSMAPIN: EINT
\end{codeseg}
means that within \code{Eos\_wrapped}, the \code{EINT\_VAR} component of \code{unk}
will be treated as the grid variable in the ``internal energy'' role for the
purpose of constructing input to \api{physics/Eos/Eos}, and
\begin{codeseg}
VARIABLE gamc EOSMAPOUT: GAMC
\end{codeseg}
means that within \code{Eos\_wrapped}, the \code{GAMC\_VAR} component of \code{unk}
will be treated as the grid variable in the \code{EOSMAP\_GAMC} role for the
purpose of returning results from calling \api{physics/Eos/Eos} to the grid.
The specification
\begin{codeseg}
VARIABLE pres EOSMAP: PRES
\end{codeseg}
has the same effect as
\begin{codeseg}
VARIABLE pres EOSMAPIN: PRES EOSMAPOUT: PRES
\end{codeseg}
Note that not all roles defined in \code{Eos\_map.h} are necessarily
meaningful or actually used in a given \unit{Eos} implementation.
An \metavar{eosmap-spec} for a \code{VARIABLE} is only used in an
 \api{physics/Eos/Eos_wrapped} invocation when the optional \code{gridDataStruct}
argument is absent or has a value of \code{CENTER}.


\item \code{FACEVAR} \metavar{name}
\metavar{[eosmap-spec]}\\
This keyword has the same meaning for face-centered variables, that
\code{VARIABLE} does for cell-centered variables. It allocates space
in the grid data structure that contains face-centered physical variables
for ``name''.  See \chpref{Sec:FlashHdimensions} for more information

For \metavar{eosmap-spec}, see above under \code{VARIABLE}.
An \metavar{eosmap-spec} for \code{FACEVAR} is only used
when \api{physics/Eos/Eos_wrapped} is called with an optional \code{gridDataStruct}
argument of \code{FACEX}, \code{FACEY}, or \code{FACEZ}.


\item \code{FLUX} \metavar{name}\\ Registers flux variable
\metavar{name} with the framework. When using an adaptive mesh, flux
conservation is needed at fine-coarse boundaries. \Paramesh uses a data
structure for this purpose, the flux variables provide indices into that
data structure.  See \chpref{Sec:FlashHfluxes} for more information.


\item \code{SCRATCHCENTERVAR} \metavar{name}
\metavar{[eosmap-spec]}\\
This keyword is used in connection with the grid scope scratch space
for cell-centered data supported by Flash-X. It allows the user to ask for scratch space with
``name''. The scratch variables do not participate in the process of
guardcell filling, and their values become invalid after a grid
refinement step. While users can define scratch variables to be
written to the plotfiles, they are not by default written to 
checkpoint files. Note this feature wasn't available in Flash-X2.
See \chpref{Sec:FlashHscratch} for more information.

\item \code{SCRATCHFACEVAR} \metavar{name}
\metavar{[eosmap-spec]}\\
This keyword is used in connection with the grid scope scratch space
for face-centered data, it is identical in every other respect to
\code{SCRATCHCENTERVAR}.

\item \code{SCRATCHVAR} \metavar{name}
\metavar{[eosmap-spec]}\\
This keyword is used for specifying instances of general purpose 
grid scope scratch space. The same space can support cell-centered as
well as face-centered data. Like other scratch data structures, the
variables in this data structure can also be asked with ``name'' and
do not participate in guardcell filling. 


For \metavar{eosmap-spec}, see above under \code{VARIABLE}.
An \metavar{eosmap-spec} for \code{SCRATCHVAR} is only used
when \api{physics/Eos/Eos_wrapped} is called with an optional \code{gridDataStruct}
argument of \code{SCRATCH}.


\item \code{MASS\_SCALAR} \metavar{name} \metavar{[RENORM: group-name]}
\metavar{[eosmap-spec]} \\
If a quantity is defined with keyword MASS\_SCALAR, space is created
for it in the grid ``unk'' data structure. It is treated like any other
variable by \Paramesh, but the hydrodynamic unit treats it
differently. It is advected, but other physical characteristics don't
apply to it. If the optional ``RENORM'' is given, this mass-scalar will be
added to the renormalization group of the accompanying group name.
The hydrodynamic solver will renormalize all mass-scalars in a given group,
ensuring that all variables in that group will sum to 1 within an individual
cell.  See \chpref{Sec:FlashHvariables}

For \metavar{eosmap-spec}, see above under \code{VARIABLE}.
An \metavar{eosmap-spec} for a \code{MASS\_SCALAR} may be used in an
 \api{physics/Eos/Eos_wrapped} invocation when the optional \code{gridDataStruct}
argument is absent or has a value of \code{CENTER}.

\begin{flashtip}[Avoid Confusion!]
% same text included in Flash.h chapter
It is inadvisable to name variables, species, and mass scalars with the same prefix,
as post-processing routines have difficulty deciphering the type of data from the 
output files.  For example, don't create a variable ``temp'' to hold
temperature and a mass scalar ``temp'' indicating a temporary variable.
Although the \code{Flash.h} file can distinguish between these two types of variables, many plotting routines cannot.
\end{flashtip} 

\item \code{PARTICLETYPE} \metavar{particle-type} \code{INITMETHOD} 
  \metavar{initialization-method} \code{MAPMETHOD}
  \metavar{map-method} \code{ADVMETHOD} \metavar{time-advance-method}\\ 
This keyword associates a \emterm{particle type} with mapping and  
initialization sub-units of \code{Particles} unit to operate on this 
particle type during the simulation.  Here, \metavar{map-method} 
describes the method used to map the particle properties to and from 
the mesh (see \secref{Sec:Particles Mapping}),
\metavar{initialization-method} describes the method used to
distribute the particles at initialization, and
\metavar{time-advance-method} describes the method used to advance the
associated particle type in time (see \secref{Sec:Particles Integration},
and in general \secref{Sec:ParticlesUsing}).
This keyword has been introduced to  facilitate inclusion of multiple
particle types in the same simulation. It imposes certain
requirements on the use of the \code{ParticlesMapping} and
\code{ParticlesInitialization} \subunits.
Particles (of any type, whether called \code{passive} or anything else)
do not have default methods for initialization, mapping, or time integration,
so a \code{PARTICLETYPE} directive in a
\code{Config} file  (or an equivalent \code{-particlemethods=} setup
option, see \secref{setupclf:particlemethods}) is the only way to 
specify the appropriate implementations of the \unit{Particles} subunits to be 
used. The declaration should be accompanied by appropriate
``REQUESTS'' or ``REQUIRES'' directives to specify the paths of the
appropriate subunit implementation directories to be included. 
For clarity, our technique has been to include this 
information in the simulation directory \code{Config} files only. All
the currently available mapping and initialization methods have a
corresponding identifier in the form of preprocessor definition in
\code{Particles.h}. The user may select any \metavar{particle-type}
name, but the \metavar{map-method}, \metavar{initialization-method}
and \metavar{time-advance-method} must correspond to existing
identifiers defined in \code{Particles.h}. This is necessary to
navigate the data  structure that stores the particle type and its
associated mapping and initialization methods. Users desirous of
adding new methods for mapping or initialization should also update
the \code{Particles.h} file with additional identifiers and their
preprocessor definitions. Note, it is possible to use the   same
methods for different particle types, but each particle type   name
must only appear once.  Finally, the Simulations \code{Config} file is
also expected to request appropriate implementations of mapping and 
initialization \subunits using the  keyword \code{REQUESTS}, since
the corresponding Config files do not specify a default implementation
to include. For example, to include \code{passive} particle
types with \code{Quadratic} mapping, \code{Lattice} initialization,and
\code{Euler} for advancing in time the following code segment should
appear in the \code{Config} file of the \code{Simulations} directory. 
\begin{codeseg}
PARTICLETYPE passive INITMETHOD lattice MAPMETHOD quadratic ADVMETHOD Euler
REQUIRES Particles/ParticlesMain
REQUESTS Particles/ParticlesMain/passive/Euler
REQUESTS Particles/ParticlesMapping/Quadratic
REQUESTS Particles/ParticlesInitialization/Lattice
\end{codeseg}

\item \code{PARTICLEPROP} \metavar{name} \metavar{type}\\
This keyword indicates that the particles data structure will allocate space for a 
sub-variable
``NAME\_\-PART\_\-PROP.'' For example if the Config file contains
\begin{codeseg}
PARTICLEPROP dens
\end{codeseg}
then the code can directly access this property as
\begin{codeseg}
particles(DENS_PART_PROP,1:localNumParticles) = densInitial
\end{codeseg}
\metavar{type} may be REAL or INT, however INT is presently unused.
See \chpref{Sec:FlashHparticles} for more information and examples.

\item \code{PARTICLEMAP} TO \metavar{partname} FROM \metavar{vartype} \metavar{varname}\\
This keyword maps the value of the particle property \metavar{partname} to
the variable \metavar{varname}.  
\metavar{vartype} can take the values VARIABLE, MASS\_SCALAR, SPECIES,
FACEX, FACEY, FACEZ, or one of SCRATCH types (SCRATCHVAR/
SCRATCHCENTERVAR, SCRATCHFACEXVAR. SCRATCHFACEYVAR, SCRATCHFACEZVAR)
These maps are used to generate \code{Simulation_\-mapParticlesVar}, which takes
the particle property \metavar{partname} and returns \metavar{varname} and \metavar{vartype}.
For example, to have a particle property tracing density:
\begin{codeseg}
PARTICLEPROP dens REAL
PARTICLEMAP TO dens FROM VARIABLE dens
\end{codeseg}
or, in a more advanced case, particle properties tracing some face-valued function Mag:
\begin{codeseg}
PARTICLEPROP Mag_x REAL
PARTICLEPROP Mag_y REAL
PARTICLEPROP Mag_z REAL
PARTICLEMAP TO Mag_x FROM FACEX Mag
PARTICLEMAP TO Mag_y FROM FACEY Mag
PARTICLEMAP TO Mag_z FROM FACEZ Mag
\end{codeseg}
Additional information on creating \code{Config} files for particles is obtained
in \secref{Sec:Particle Properties}.



\item \code{SPECIES} \metavar{name} [TO \metavar{number of ions}] \\
An application that uses multiple species uses this keyword to define
them.  See \chpref{Sec:FlashHvariables} for more information.  The
user may also specify an optional number of ions for each element, 
\metavar{name}.  For example, \code{SPECIES} \metavar{o} TO
\metavar{8} creates 9 spaces in \code{unk} for Oxygen, that is, a
single space for Oxygen and 8 spaces for each of its ions.  This is
relevant to simulations using the \code{ionize} unit.  (Omitting the
optional \code{TO} specifier is equivalent to specifying \code{TO} 0).


\item \code{DATAFILES} \metavar{wildcard}\\
Declares that all files matching the given wildcard in the unit directory should
be copied over to the object directory. For example,
\begin{codeseg}
DATAFILES *.dat
\end{codeseg}
will copy all the ``.dat'' files to the object directory.



\item \code{KERNEL} \metavar{[subdir]}\\
Declares that all subdirectories must be recursively included. This
usually marks the end of the high level architecture of a unit.
Directories below it may be third party software or a highly optimized
solver, and are therefore not required to conform to Flash-X architecture.

Without a \metavar{subdir}, the current directory (\ie, the one containing
the \code{Config} file with the \code{KERNEL} keyword) is marked as
a kernel directory, so code from all its subdirectories (with the exception
of subdirectories whose name begins with a dot) is included.
When a \metavar{subdir} is given, then that subdirectory must exist,
and it is treated as a kernel directory in the same way.

Note that currently the \code{setup} script can process only one \code{KERNEL} directive
per \code{Config} file.

\item \code{LIBRARY} \metavar{name}\\
Specifies a library requirement.  Different Flash-X units require different
libraries, and they must inform \code{setup} so it can link the libraries into the
executable.  Some valid library names are \code{HDF5, MPI}.  Support
for external libraries can be added by modifying the site-specific
\code{Makefile.h} files to include appropriate Makefile macros. It is
possible to use internal libraries, as well as switch libraries at
setup time. To use these features, see \newline
%\weblink{\makeHowtoURL{Library-HOWTO}}{Library-HOWTO}.



\item \code{LINKIF} \metavar{filename unitname}\\
Specifies that the file \metavar{filename} should be used only when the
unit \unit{\metavar{unitname}} is included. This keyword allows a unit to have
multiple implementations of any part of its functionality, even down
to the kernel level, without the necessity of creating children for every
alternative. This is especially useful in Simulation setups where
users may want to use different implementations of specific functions
based upon the units included.  For instance, a user may wish to supply
his/her own implementation of \code{Grid\_markRefineDerefine.F90},
instead of using the default one provided by Flash-X. However, this function
is aware of the internal workings of \unit{Grid}, and has different implementations for
different grid packages. The user could therefore specify different versions of
his/her own file that are intended for use with the different grids. For example,
adding
\begin{codeseg}
 LINKIF Grid_markRefineDerefine.F90.ug Grid/GridMain/UG
 LINKIF Grid_markRefineDerefine.F90.pmesh Grid/GridMain/paramesh
\end{codeseg}
to the \code{Config} file ensures that if the application is built with
\unit{UG}, the file
\newline % prevent overfull
\code{Grid\_markRefineDerefine.F90.ug} will be linked
in as \code{Grid\_markRefineDerefine.F90}, whereas if it is built with
\unit{Paramesh2} or \unit{Paramesh4.0} or \unit{Paramesh4dev},
then the file \code{Grid\_markRefineDerefine\-.F90\-.pmesh} will be
linked in as \code{Grid\_markRefineDerefine.F90}. Alternatively,
the user may want to provide only one implementation specific to,
say, \Paramesh. In this case, adding
\begin{codeseg}
 LINKIF Grid_markRefineDerefine.F90 Grid/GridMain/paramesh
\end{codeseg}
to the Config file ensures that the user-supplied file is included
when using \Paramesh (either version), while the default Flash-X file is
included when using \unit{UG}.

\item \code{PPDEFINE} \metavar{sym1 sym2 ...}\\
Instructs setup to add the PreProcessor symbols \code{\metavar{SYM1}} and
\code{\metavar{SYM2}} to the
generated \code{Flash.h}. Here \code{\metavar{SYM1}} is \metavar{sym1}
converted to uppercase.
These pre-process symbols can be used in the code to distinguish
between which units have been used in an application. For example,
a Fortran subroutine could include
\begin{codeseg}
#ifdef Flash-X_GRID_UG
  ug specific code
#endif

#ifdef Flash-X_GRID_PARAMESH3OR4
  pm3+ specific code
#endif
\end{codeseg}
By convention, many preprocessor symbols defined in Config
files included in the Flash-X code distribution
start with the prefix ``Flash-X\_''.

\item \code{USESETUPVARS \metavar{var1, var2, \dots}}\\
This tells \setup that the specified ``Setup Variables'' are being used
in this \code{Config} file. The variables initialize to an empty
string if no values are specified for them. Note that commas
are required if listing several variables.



\item \code{CHILDORDER} \metavar{child1 child2 \dots}\\
When \code{setup} links several implementations of the same
function, it ensures that implementations of children override that
of the parent. Its method is to lexicographically sort all
the names and allow implementations occurring later to override
those occurring earlier. This means that if two siblings
implement the same code, the names of the siblings determine which
implementation wins. Although it is very rare for two siblings to
implement the same function, it does occur. This keyword permits the
\code{Config} file to override the lexicographic order by one
preferred by the user. Lexicographic ordering will prevail as usual
when deciding among implementations that are not explicitly listed.

\item \code{GUARDCELLS} \metavar{num}\\
Allows an application to choose the stencil size for updating
grid points. The stencil determines the number of guardcells
needed. The PPM algorithm requires $4$ guardcells, hence that is the
default value.
If an application specifies a smaller value, it will probably not
be able to use the default \code{monotonic} AMR Grid interpolation;
see the \code{-gridinterpolation} \code{setup} flag for additional
information.

\item \code{SETUPERROR \textit{error message}}\\
This causes \setup to abort with the specified error message. This
is usually used only inside a conditional IF/ENDIF block (see below).

\item \code{IF, ELSEIF, ELSE, ENDIF}\\
A conditional block is of the following form:
\begin{codeseg}
IF cond
   ...
ELSEIF cond
   ...
ELSE
   ...
ENDIF
\end{codeseg}

\noindent where the \code{ELSEIF} and \code{ELSE} blocks are optional. There
is no limit on the number of \code{ELSEIF} blocks. ``...'' is any sequence
of valid \code{Config} file syntax. The conditional blocks may be nested.
``cond'' is any boolean valued Python expression using the setup variables
specified in the \code{USESETUPVARS}.

\item \code{NONREP} \metavar{unktype} \metavar{name} \metavar{localmax} \metavar{globalparam}
\metavar{ioformat}\\
Declares an array of \code{UNK} variables that will be partitioned across the
replicated meshes.  Using various preprocessor macros in Flash.h each copy of
the mesh can determine at runtime its own subset of indexes into this global
array.  This allows an easy form of parallelism where regular "replicated"
mesh variables are computed redundantly across processors, but the variables in
the "non-replicated" array are computed in parallel.

\begin{itemize}
\item \metavar{unktype}: must be either \code{MASS_SCALAR} or \code{VARIABLE}\\

\item \metavar{name}: the name of this variable array.  It is suggested that it be
all capital letters, and must conform to what the C preprocessor will consider as
a valid symbol for use in a \code{\#define} statement.

\item \metavar{localmax}: a positive integer specifying the maximum number of elements
from the global variable array a mesh can hold.  This is the actual number of
\code{UNK} variables that are allocated on each processor, though not all of
them will necessarily be used.\\

\item \metavar{globalparam}: the name of a runtime parameter which dictates the size
of this global array of variables.\\

\item \metavar{ioformat}: a string representing how the elements of the array will
be named when written to the output files.  The question mark character \code{?} is
used as a placeholder for the digits of the array index.  As an example, the format
string \code{x???} will generate the dataset names \code{x001}, \code{x002},
\code{x003}, etc.  This string must be no more than four characters in length.\\
\end{itemize}

The number of meshes is dictated by the runtime parameter \code{meshCopyCount}.  The
following constraint must be satisfied or Flash-X will fail at runtime:
\[globalparam \le meshCopyCount * localmax\]
The reason for this restriction is that \code{localmax} is the maximum number of
array elements a mesh can be responsible for, and \code{meshCopyCount} is the number of
meshes, so their product bounds the size of the array.

Example:

Config file:
\begin{fcodeseg}
NONREP MASS_SCALAR A 4 numA a???
NONREP MASS_SCALAR B 5 numB b???
\end{fcodeseg}

flash.par file:
\begin{fcodeseg}
meshCopyCount = 3
numA = 11
numB = 15
\end{fcodeseg}

In this case two non-replicated mass-scalar arrays are defined, \code{A} and
\code{B}.  Their lengths are specified by the runtime parameters \code{numA} and
\code{numB} respectively.  \code{numB} is set to its maximum value of $5*meshCopyCount=15$,
but \code{numA} is one less than its maximum value of $4*meshCopyCount=12$ so at runtime
one of the meshes will not have all of its \code{UNK} variables in use.  The
dataset names generated by IO will take the form \code{a001 \dots a011} and
\code{b001 \dots b015}.

The preprocessor macros defined in \code{Flash.h} for these arrays will have the
prefixes \code{A_} and \code{B_} respectively.  For details about these macros and
how they will distribute the array elements across the meshes see \secref{Sec:FlashHnonrep}.


\end{itemize}

\begin{comment}
\section{Reordering unk indices}\label{Sec:index-reorder}

By default the unk datastructure has the following declaration
\code{unk(VARS,X,Y,Z,BLOCK)}. For performance reasons one might want
to change the order so that the datastructure looks like
\code{unk(X,Y,Z,VARS,BLOCK)}. The \code{-index-reorder} flag to \setup
instructs setup to implement this change. This change is implemented at
various levels.

\textbf{Setup Variables}: The \code{-index-reorder} option causes \setup
to set the \code{IndexReorder} setup variable to \code{True}. \code{Config}
files can then use this to decide which implementation to include. For example,
\code{Grid/GridMain/UG/Config} uses the \code{UGReordered}
implementation when \code{IndexReorder} is set to true.

\textbf{Pre Processor Symbol}: The \code{-index-reorder} option
defines a pre-processor symbol \code{INDEXREORDER}. This enables
one to write code which do things things differently, based
on whether re-ordering is in effect or not. For example,
\begin{codeseg}
#ifdef INDEXREORDER
   xn(:,:) = solnData(:,:,j,k)
#else
   xn(:,:) = transpose(solnData(:,:,j,k))
#endif
\end{codeseg}

Note that in the first clause, where unk indices are meant to be reordered,
the order of indices is the same in the ``else'' clause. This is because,
if \code{INDEXREORDER} is set, the order of the indices will be changed
automatically by \code{setup_reorder.py}. If you need to use a lot of these
\verb?#ifdef?'s, you might be better off creating a re-ordered implementation
of the function in question.

\textbf{Makefile}: The \code{-index-reorder} option
causes \code{make} to invoke the \code{reorder.sh} script in the
\code{object} directory. This script is generated by \code{setup_depends.py}
when \code{make} is run initially and contains calls to \code{setup_reorder.py},
which rewrites Fortran code to handle the re-ordering.

\subsection{Rewriting F90 code}
The \code{setup_reorder.py} script takes as input a Fortran90 file, say
\code{file.F90}. Information about which variables need to be re-ordered
must be present in the file itself. More specifically, the script scans
the source code for lines of the form
\begin{codeseg}
!!REORDER(<n>): <varlist>
\end{codeseg}
\noindent where \verb!<n>! is either 4 or 5 and \verb!<varlist>! is a list of
variable names.  This means that the specified variables are of the given
dimension (4 or 5) and that all array accesses of the form \code{avar(v,x,y,z,b)}
and \code{bvar(v,x,y,z)} are translated to \code{avar(x,y,z,v,b)} and
\code{bvar(x,y,z,v)} respectively.  These \verb?!!REORDER? lines may appear any
number of times in the source code. It is recommended, however, that one put the
\verb?!!REORDER? line immediately after the variable declaration.

\textbf{Caveat}: Since array declarations also need to be changed, the arrays should
be declared in a way that makes it possible for \code{setup_reorder.py} to re-order
them as well, \eg, use:
\begin{codeseg}
real :: solnData(NVARS,10,10,10)
\end{codeseg}
instead of
\begin{codeseg}
real, dimension(NVARS,10,10,10) :: solnData
\end{codeseg}

The input file \code{file.F90} is renamed to \code{file.F90.orig} and the rewritten
code is written to \code{file.F90}. The \code{reorder.sh} calls \code{setup_reorder.py} to
rewrite \code{file.F90} only if \code{file.F90.orig} has changed.
Thus the user only needs to edit \code{file.F90.orig} which is usually a link to a
working copy of the appropriate implementation of \code{file.F90}.
\end{comment}
\section{Creating a Site-specific \code{Makefile}}
\label{Sec:SetupMakefile}

If \setup does not find your hostname in the \code{sites/} directory
it picks a default \code{Makefile} based on the operating system.
This \code{Makefile} is not always correct but can be used as a
template to create a \code{Makefile} for your machine. To create a
Makefile specific to your system follow these instructions.

\begin{itemize}
\item Create the directory \code{sites/<hostname>}, where \code{<hostname>}
is the hostname of your machine.

\item Start by copying \code{os/<your os>/Makefile.h} to \code{sites/<hostname>}

\item Use \code{bin/suggestMakefile.sh} to help identify the
locations of various libraries on your system. The script scans your
system and displays the locations of some libraries. You must note
the location of \code{MPI} library as well. If your compiler is actually
an mpi-wrapper (\eg \code{mpif90}), you must still define \code{LIB\_MPI} in your
site specific \code{Makefile.h} as the empty string.

\item Edit \code{sites/<hostname>/Makefile.h} to provide the locations of
various libraries on your system.

\item Edit \code{sites/<hostname>/Makefile.h} to specify the \FORTRAN\
and C compilers to be used.
\end{itemize}

\begin{flashtip}[Actual Compiler or MPI wrapper?]
If you have \code{MPI} installed, you can either specify the actual
compiler (\eg \code{f90}) or the mpi-wrapper (\eg \code{mpif90}) for
the ``compiler'' to be used on your system. Specifying the
actual compiler and the location of the MPI libraries in the site-specific
Makefile allows you the possibility of switching your MPI implementation.
For more information see
%\weblink{\makeHowtoURL{Library-HOWTO}}{Library-HOWTO}.
\end{flashtip}

\begin{flashtip}[Compilation warning]
The Makefile.h \emph{must} include a compiler flag to promote Fortran
\code{Reals} to \code{Double Precision}.  Flash-X performs all
\code{MPI} communication of Fortran \code{Reals} using
\code{MPI_DOUBLE_PRECISION} type, and assumes that Fortran
\code{Reals} are interoperable with C \code{doubles} in the I/O unit.
\end{flashtip}

\begin{flashtip}[HDF5 Library Interface]
If you are using HDF5 for I/O, and your HDF5 library version is
greater than 1.6.x, the C source files of the \code{IO} unit need to be compiled
with the preprocessor symbol \code{H5\_USE\_16\_API}%\index{H5\_USE\_16\_API@\code{H5\_USE\_16\_API}}
defined. This is usually best achieved by having a line
like the following in your Makefile.h:
\begin{verbatim}
CFLAGS_HDF5  = -I${HDF5_PATH}/include -DH5_USE_16_API
\end{verbatim}
\end{flashtip}


\section{Files Created During the \code{setup} Process}

When \setup is run it generates many files in the \code{object}
directory. They fall into three major categories:

\begin{itemize}
\item[(a)] Files not required to build the Flash-X executable, but
which contain useful information,
\item[(b)] Generated \Fortran90 or C code, and
\item[(c)] Makefiles required to compile the Flash-X executable.
\end{itemize}

\subsection{Informational files}
These files are generated before compilation by \setup. Each of these
files begins with the prefix \code{setup_} for easy identification.

\vspace{0.5in}
\begin{tabular}{|lp{0.60\textwidth}|}
\hline%
\grayrow\code{setup\_call} & contains the options with which \setup
was called and the command line resulting after shortcut
expansion\eor

\code{setup\_libraries} & contains the list of libraries and their
arguments (if any) which was linked in to generate the executable
\eor

\grayrow \code{setup\_units} & contains the list of all units which
were included in the current setup\eor %

\code{setup\_defines} & contains a list of all pre-process symbols
passed to the compiler invocation directly \eor%

\grayrow\code{setup\_flags} & contains the exact
compiler and linker flags \eor %

\code{setup\_params} & contains the list of runtime parameters
defined in the \code{Config} files processed by \setup \eor

\grayrow \code{setup\_vars} & contains the list of variables,
fluxes, species, particle properties, and mass scalars used
in the current setup, together with their descriptions.  \eor
\hline
\end{tabular}

\subsection{Code generated by the \code{setup} call}

These routines are generated by the setup call and provide
simulation-specific code.

\begin{tabular}{|lp{0.55\textwidth}|}
\hline
\code{setup\_buildstamp.F90} & contains code for the subroutine
\code{setup\_buildstamp} which returns the setup and build time as
well as code for \code{setup\_systemInfo} which returns the
\emph{uname} of the system used to setup the problem\eor

\grayrow \code{setup\_buildstats.c} & contains code which returns build
statistics including the actual \code{setup} call as well as the compiler
flags used for the build \eor

\code{setup\_getFlashUnits.F90} & contains code to retrieve the number and
list of flashUnits used to compile code \eor


\grayrow \code{setup\_flashRelease.F90} & contains code to retrieve the
version of Flash-X used for the build \eor

\code{Flash.h} & contains simulation specific preprocessor macros, which change
based upon setup unlike \code{constants.h}. It is described in \chpref{Chp:Flash.h} \eor

\hline %
\grayrow \api{Simulation/Simulation_mapIntToStr}\code{.F90} & contains code to map
an index described in \code{Flash.h} to a string described in the \code{Config} file. \eor

\api{Simulation/Simulation_mapStrToInt}\code{.F90} & contains code to map a string
described in the \code{Config} file to an integer index described in the \code{Flash.h}
file. \eor

\grayrow \api{Simulation/Simulation_mapParticlesVar}\code{.F90} & contains a
mapping between particle properties and grid variables.  Only generated when particles
are included in a simulation.\eor

\api{Particles/Particles_specifyMethods}\code{.F90} & contains code to make a data structure
with information about the mapping and initialization method for each type of particle.
Only generated when particles are included in a simulation. \eor
\hline %
\end{tabular}

\subsection{Makefiles generated by \code{setup}}
\label{Sec:unitMakefiles}

Apart from the master \code{Makefile}, \setup generates a makefile for
each unit, which is ``included'' in the master \code{Makefile}. This
is true even if the unit is not included in the application. These
unit makefiles  are named \code{Makefile.Unit} and are a concatenation
of all the Makefiles found in unit hierarchy processed by \setup.

For example, if an application uses
\code{Grid/GridMain/paramesh/paramesh4/Paramesh4.0}, the file 
\newline
\code{Makefile.Grid}
will be a concatenation of the Makefiles found in
\begin{itemize}
\item \code{Grid},
\item \code{Grid/GridMain},
\item \code{Grid/GridMain/paramesh},
\item \code{Grid/GridMain/paramesh/paramesh4}, and
\item \code{Grid/GridMain/paramesh/paramesh4/Paramesh4.0}
\end{itemize}

As another example, if an application does not use \code{PhysicalConstants}, then
\code{Makefile.\-Physical\-Constants} is just the contents of
\code{PhysicalConstants/Makefile} at the API level.

Since the order of concatenation is arbitrary, the behavior of the
Makefiles should not depend on the order in which they have been
concatenated. The makefiles inside the units contain lines of the form:
\begin{codeseg}
Unit += file1.o file2.o ...
\end{codeseg}

\noindent where \code{Unit} is the name of the unit, which was \code{Grid} in
the example above.  Dependency on data
modules files \emph{need not be specified} since the setup process
determines this requirement automatically.

\section{Setup a hybrid MPI+OpenMP Flash-X application}
\label{Sec:hybridSetup}

There is the experimental inclusion of Flash-X multithreading with
OpenMP in the \flashx beta release.  The units which have support
for multithreading are split hydrodynamics \ref{Sec:PPM}, unsplit
hydrodynamics \ref{Sec:unsplit hydro algorithm}, Gamma law and
multigamma EOS \ref{Sec:Eos Gammas}, Helmholtz EOS \ref{Sec:Eos Helmholtz}, 
Multipole Poisson solver (improved version (support for
2D cylindrical and 3D cartesian))
\ref{Sec:GridSolversMultipoleImproved} and energy deposition
\ref{Sec:EnergyDeposition}.

The Flash-X multithreading requires a MPI-2 installation built with
thread support (building with an MPI-1 installation or an MPI-2
installation without thread support is possible but strongly
discouraged).  The Flash-X application requests the thread support level
\code{MPI_THREAD_SERIALIZED} to ensure that the MPI library is
thread-safe and that any OpenMP thread can call MPI functions safely.
You should also make sure that your compiler provides a version of
OpenMP which is compliant with at least the OpenMP 2.5 (200505)
standard (older versions may also work but I have not checked).

In order to make use of the multithreaded code you must setup your
application with one of the setup variables \code{threadBlockList},
\code{threadWithinBlock} or \code{threadRayTrace} equal to
\code{True}, e.g.

\begin{codeseg}
./setup Sedov -auto threadBlockList=True
./setup Sedov -auto threadBlockList=True +mpi1 (compatible with MPI-1 - unsafe!)
\end{codeseg}


When you do this the setup script will insert \code{USEOPENMP = 1}
instead of \code{USEOPENMP = 0} in the generated Makefile.  If it is
equal to $1$ the Makefile will prepend an OpenMP variable to the
\code{FFLAGS}, \code{CFLAGS}, \code{LFLAGS} variables.


\begin{flashtip}[Makefile.h variables]
In general you should not define \code{FLAGS}, \code{CFLAGS} and
\code{LFLAGS} in your \code{Makefile.h}.  It is much better to define
\code{FFLAGS_OPT}, \code{FFLAGS_TEST}, \code{FFLAGS_DEBUG},
\code{CFLAGS_OPT}, \code{CFLAGS_TEST}, \code{CFLAGS_DEBUG},
\code{LFLAGS_OPT}, \code{LFLAGS_TEST} and \code{LFLAGS_DEBUG} in your
\code{Makefile.h}.  The setup script will then initialize the
\code{FFLAGS}, \code{CFLAGS} and \code{LFLAGS} variables in the
Makefile appropriately for an optimized, test or debug build.
\end{flashtip}

The OpenMP variables should be defined in your \code{Makefile.h} and
contain a compiler flag to recognize OpenMP directives.  In most cases
it is sufficient to define a single variable named \code{OPENMP}, but
you may encounter special situations when you need to define
\code{OPENMP_FORTRAN}, \code{OPENMP_C} and \code{OPENMP_LINK}.  If you
want to build Flash-X with the GNU Fortran compiler \code{gfortran} and
the GNU C compiler \code{gcc} then your \code{Makefile.h} should
contain

\begin{codeseg}
OPENMP = -fopenmp
\end{codeseg}

If you want to do something more complicated like build Flash-X with the
Lahey Fortran compiler \code{lf90} and the GNU C compiler \code{gcc}
then your \code{Makefile.h} should contain

\begin{codeseg}
OPENMP_FORTRAN = --openmp -Kpureomp
OPENMP_C = -fopenmp
OPENMP_LINK = --openmp -Kpureomp
\end{codeseg}

When you run the hybrid Flash-X application it will print the level of
thread support provided by the MPI library and the number of OpenMP
threads in each parallel region

\begin{codeseg}
[Driver_initParallel]: Called MPI_Init_thread - requested level   2, given level   2
[Driver_initParallel]: Number of OpenMP threads in each parallel region  4
\end{codeseg}

Note that the Flash-X application will still run if the MPI library does
not provide the requested level of thread support, but will print a
warning message alerting you to an unsafe level of MPI thread support.
There is no guarantee that the program will work!  I strongly
recommend that you stop using this Flash-X application - you should
build a MPI-2 library with thread support and then rebuild Flash-X.

We record extra version and runtime information in the Flash-X log file
for a threaded application.  Table \ref{tab:flash_openmp_logs} shows
log file entries from a threaded Flash-X application along with example
safe and unsafe values.  All cells colored red show unsafe values.

\begin{table}[!h]
\begin{center}
    \begin{tabular}{ | l | l | l | l | l |}
    \hline

    {\bf Log file stamp} & {\bf safe} & {\bf unsafe (1)} & {\bf unsafe
      (2)} & {\bf unsafe (3)}\\ \hline

    Number of MPI tasks:                  & 1 & 1 & 1 & 1\\ \hline
    MPI version:                          & 2 & \cellcolor{red} 1 & 2 & 2\\ \hline
    MPI subversion:                       & 2 & 2 & 1 & 2\\ \hline
    MPI thread support:                   & T & \cellcolor{red} F & \cellcolor{red} F & \cellcolor{red} F\\ \hline
    OpenMP threads/MPI task:              & 2 & 2 & 2 & 2\\ \hline
    OpenMP version:                       & 200805 & 200505 & 200505 & 200805\\ \hline
    Is ``\_OPENMP'' macro defined:        & T & T & T & \cellcolor{red} F\\ \hline

    \end{tabular}
    \caption{Log file entries showing safe and unsafe threaded Flash-X
      applications}
    \label{tab:flash_openmp_logs}
\end{center}
\end{table}

The Flash-X applications in Table \ref{tab:flash_openmp_logs} are unsafe
because

\begin{enumerate}
\item we are using an MPI-1 implementation.

\item we are using an MPI-2 implementation which is not built with
  thread support - the ``MPI thread support in OpenMPI'' Flash tip may
  help.

\item we are using a compiler that does not define the macro
  \code{_OPENMP} when it compiles source files with OpenMP support
  (see OpenMP standard).  I have noticed that Absoft 64-bit Pro
  Fortran 11.1.3 for Linux x86\_64 does not define this macro.  We use
  this macro in \code{Driver_initParallel.F90} to conditionally
  initialize MPI with \code{MPI_Init_thread}.  If you find that
  \code{_OPENMP} is not defined you should define it in your
  \code{Makefile.h} in a manner similar to the following:
\begin{codeseg}
OPENMP_FORTRAN = -openmp -D_OPENMP=200805
\end{codeseg}

\end{enumerate}


\begin{flashtip}[MPI thread support in OpenMPI]
A default installation of OpenMPI-1.5 (and earlier) does not provide
any level of MPI thread support.  To include MPI thread support you
must configure OpenMPI-1.5 with \code{--enable-mpi-thread-multiple} or
\code{--enable-opal-multi-threads}.  We prefer to configure with
\code{--enable-mpi-thread-multiple} so that we can (in future) use the
highest level of thread support.  The configure option is named
\code{--enable-mpi-threads} in earlier versions of OpenMPI.
\end{flashtip}

\begin{flashtip}[MPI-IO issues when using a threaded Flash-X application]
The ROMIO in older versions of MPICH2 and OpenMPI is known to be
buggy.  We have encountered a segmentation fault on one platform and a
deadlock on another platform during MPI-IO when we used OpenMPI-1.4.4
with a multithreaded Flash-X application.  We solved the error by using
OpenMPI-1.5.4 (it should be possible to use OpenMPI-1.5.2 or greater
because the release notes for OpenMPI-1.5.2 state ``- Updated ROMIO
from MPICH v1.3.1 (plus one additional patch).''.  We have not tested
to find the minimum version of MPICH2 but MPICH2-1.4.1p1 works fine.
If it is not possible to use a newer MPI implementation you can avoid
MPI-IO altogether by setting up your Flash-X application with
\code{+serialIO}.
\end{flashtip}

You should not setup a Flash-X application with both
\code{threadBlockList} and \code{threadWithinBlock} equal to
\code{True} - nested OpenMP parallelism is not supported.  For further
information about Flash-X multithreaded applications please refer to
Chapter \ref{Chp:MultithreadedFlash-X}.

