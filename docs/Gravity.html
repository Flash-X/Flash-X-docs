<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gravity Unit &mdash; Flash-X 0.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Particles Unit" href="Particles.html" />
    <link rel="prev" title="Local Source Terms" href="sourceTerms.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Flash-X
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="disclaimers.html">Current Status and Disclaimers</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Overview of Flash-X architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">The Flash-X configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="driver.html">Driver Unit</a></li>
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="physics.html">Physics Units</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Hydro.html">Hydrodynamics Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="IncompNS.html">Incompressible Navier-Stokes Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="Eos.html">Equation of State Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="sourceTerms.html">Local Source Terms</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Gravity Unit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#externally-applied-fields">Externally Applied Fields</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constant-gravitational-field">Constant Gravitational Field</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plane-parallel-gravitational-field">Plane-parallel Gravitational field</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gravitational-field-of-a-point-mass">Gravitational Field of a Point Mass</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-defined-gravitational-field">User-Defined Gravitational Field</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#self-gravity">Self-gravity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#coupling-gravity-with-hydrodynamics">Coupling Gravity with Hydrodynamics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tree-gravity">Tree Gravity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tree-gravity-unit-usage">Tree Gravity Unit Usage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unit-tests">Unit Tests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Particles.html">Particles Unit</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monitor.html">Monitor Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Flash-X</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="physics.html">Physics Units</a> &raquo;</li>
      <li>Gravity Unit</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Gravity.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="gravity-unit">
<span id="chp-gravity"></span><h1>Gravity Unit<a class="headerlink" href="#gravity-unit" title="Permalink to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Gravity</span></code> unit supplied with Flash-X computes gravitational source
terms for the code. These source terms can take the form of the
gravitational potential <span class="math notranslate nohighlight">\(\phi({\bf x})\)</span> or the gravitational
acceleration <span class="math notranslate nohighlight">\({\bf g}({\bf x})\)</span>,</p>
<div class="math notranslate nohighlight">
\[{\bf g}({\bf x}) = -\nabla \phi({\bf x})\ .\]</div>
<p>The gravitational field can be externally imposed or self-consistently
computed from the gas density via the Poisson equation,</p>
<div class="math notranslate nohighlight">
\[\label{Eqn:Poisson}
\nabla^2\phi({\bf x}) = 4\pi G \rho({\bf x})\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(G\)</span> is Newton’s gravitational constant. In the latter case,
either periodic or isolated boundary conditions can be applied.</p>
</section>
<section id="externally-applied-fields">
<span id="sec-gravityexternal"></span><h2>Externally Applied Fields<a class="headerlink" href="#externally-applied-fields" title="Permalink to this heading"></a></h2>
<p>The Flash-X distribution includes three externally applied gravitational
fields, along with a placeholder module for you to create your own. Each
provides the acceleration vector <span class="math notranslate nohighlight">\({\bf g}({\bf x})\)</span> directly,
without using the gravitational potential <span class="math notranslate nohighlight">\(\phi({\bf x})\)</span> (with
the exception of <code class="docutils literal notranslate"><span class="pre">UserDefined</span></code>, see below).</p>
<p>When building an application that uses an external, time-independent
<code class="docutils literal notranslate"><span class="pre">Gravity</span></code> implementation, no additional storage in <code class="docutils literal notranslate"><span class="pre">unk</span></code> for holding
gravitational potential or accelerations is needed or defined.</p>
<section id="constant-gravitational-field">
<h3>Constant Gravitational Field<a class="headerlink" href="#constant-gravitational-field" title="Permalink to this heading"></a></h3>
<p>This implementation creates a spatially and temporally constant field
parallel to one of the coordinate axes. The magnitude and direction of
the field can be set at runtime. This unit is called
<code class="docutils literal notranslate"><span class="pre">Gravity/GravityMain/Constant</span></code>.</p>
</section>
<section id="plane-parallel-gravitational-field">
<h3>Plane-parallel Gravitational field<a class="headerlink" href="#plane-parallel-gravitational-field" title="Permalink to this heading"></a></h3>
<p>This <code class="docutils literal notranslate"><span class="pre">PlanePar</span></code> version implements a time-constant gravitational field
that is parallel to one of the coordinate axes and falls off with the
square of the distance from a fixed location. The field is assumed to be
generated by a point mass or by a spherically symmetric mass
distribution. A finite softening length may optionally be applied.</p>
<p>This type of gravitational field is useful when the computational domain
is large enough in the direction radial to the field source that the
field is not approximately constant, but the domain’s dimension
perpendicular to the radial direction is small compared to the distance
to the source. In this case the angular variation of the field direction
may be ignored. The <code class="docutils literal notranslate"><span class="pre">PlanePar</span></code> field is cheaper to compute than the
<code class="docutils literal notranslate"><span class="pre">PointMass</span></code> field described below, since no fractional powers of the
distance are required. The acceleration vector is parallel to one of the
coordinate axes, and its magnitude drops off with distance along that
axis as the inverse distance squared. Its magnitude and direction are
independent of the other two coordinates.</p>
</section>
<section id="gravitational-field-of-a-point-mass">
<h3>Gravitational Field of a Point Mass<a class="headerlink" href="#gravitational-field-of-a-point-mass" title="Permalink to this heading"></a></h3>
<p>This <code class="docutils literal notranslate"><span class="pre">PointMass</span></code> implementation describes the gravitational field due
to a point mass at a fixed location. A finite softening length may
optionally be applied. The acceleration falls off with the square of the
distance from a given point. The acceleration vector is everywhere
directed toward this point.</p>
</section>
<section id="user-defined-gravitational-field">
<h3>User-Defined Gravitational Field<a class="headerlink" href="#user-defined-gravitational-field" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">UserDefined</span></code> implementation is a placeholder module for the user
to create their own external gravitational field. All of the subroutines
in this module are stubs, and the user may copy these stubs to their
setup directory to write their own implementation, either by specifying
the gravitational acceleration directly or by specifying the
gravitational potential and taking its gradient. If your user-defined
gravitational field is time-varying, you may also want to set
<code class="docutils literal notranslate"><span class="pre">PPDEFINE</span> <span class="pre">|flashx|_GRAVITY_TIMEDEP</span></code> in your setup’s Config file.</p>
</section>
</section>
<section id="self-gravity">
<span id="sec-gravityselfgravity"></span><h2>Self-gravity<a class="headerlink" href="#self-gravity" title="Permalink to this heading"></a></h2>
<p>The self-consistent gravity algorithm supplied with Flash-X computes the
Newtonian gravitational field produced by the matter. The produced
potential function satisfies Poisson’s equation
<a class="reference external" href="#Eqn:Poisson">[Eqn:Poisson]</a>. This unit’s implementation can also
return the acceleration field <span class="math notranslate nohighlight">\({\bf g}({\bf x})\)</span> computed by
finite-differencing the potential using the expressions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\nonumber
g_{x;ijk} &amp;= {1\over2\Delta x}\left(\phi_{i-1,j,k} - \phi_{i+1,j,k}\right) +
  {\cal O}(\Delta x^2) \\
g_{y;ijk} &amp;= {1\over2\Delta y}\left(\phi_{i,j-1,k} - \phi_{i,j+1,k}\right) +
  {\cal O}(\Delta y^2) \\
\nonumber
g_{z;ijk} &amp;= {1\over2\Delta z}\left(\phi_{i,j,k-1} - \phi_{i,j,k+1}\right) +
  {\cal O}(\Delta z^2) \ .\end{aligned}\end{split}\]</div>
<p>In order to preserve the second-order accuracy of these expressions at
jumps in grid refinement, it is important to use quadratic interpolants
when filling guard cells at such locations. Otherwise, the truncation
error of the interpolants will produce unphysical forces at these block
boundaries.</p>
<p>Two algorithms are available for solving the Poisson equations:
<code class="docutils literal notranslate"><span class="pre">Gravity/GravityMain/Multipole</span></code> and <code class="docutils literal notranslate"><span class="pre">Gravity/GravityMain/Multigrid</span></code>.
The initialization routines for these algorithms are contained in the
<code class="docutils literal notranslate"><span class="pre">Gravity</span></code> unit, but the actual implementations are contained below the
<code class="docutils literal notranslate"><span class="pre">Grid</span></code> unit due to code architecture constraints.</p>
<p>The multipole-based solver described in for self gravity is appropriate
for spherical or nearly-spherical mass distributions with isolated
boundary conditions. For non-spherical mass distributions higher order
moments of the solver must be used. Note that storage and CPU costs
scale roughly as the square of number of moments used, so it is best to
use this solver only for nearly spherical matter distributions.</p>
<p>The multigrid solver described in is appropriate for general mass
distributions and can solve problems with more general boundary
conditions.</p>
<p>The tree solver described in
<a class="reference external" href="#Sec:GridSolversBHTree">[Sec:GridSolversBHTree]</a> is appropriate for
general mass distributions and can solve problems with both isolated and
periodic boundary conditions set independently in individual directions.</p>
<section id="coupling-gravity-with-hydrodynamics">
<h3>Coupling Gravity with Hydrodynamics<a class="headerlink" href="#coupling-gravity-with-hydrodynamics" title="Permalink to this heading"></a></h3>
<p>The gravitational field couples to the Euler equations only through the
momentum and energy equations. If we define the total energy density as</p>
<div class="math notranslate nohighlight">
\[\rho E \equiv {1\over 2}\rho v^2 + \rho\epsilon\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon\)</span> is the specific internal energy, then the
gravitational source terms for the momentum and energy equations are
<span class="math notranslate nohighlight">\(\rho{\bf g}\)</span> and <span class="math notranslate nohighlight">\(\rho{\bf v}\cdot{\bf g}\)</span>, respectively.
Because of the variety of ways in which different hydrodynamics schemes
treat these source terms, the gravity module only supplies the potential
<span class="math notranslate nohighlight">\(\phi\)</span> and acceleration <span class="math notranslate nohighlight">\({\bf g}\)</span>, leaving the
implementation of the fluid coupling to the hydrodynamics module.
Finite-difference and finite-volume hydrodynamic schemes apply the
source terms in their advection steps, sometimes at multiple
intermediate timesteps and sometimes using staggered meshes for vector
quantities like <span class="math notranslate nohighlight">\({\bf v}\)</span> and <span class="math notranslate nohighlight">\({\bf g}\)</span>.</p>
<p>For example, the PPM algorithm supplied with Flash-X uses the following
update steps to obtain the momentum and energy in cell <span class="math notranslate nohighlight">\(i\)</span> at
timestep <span class="math notranslate nohighlight">\(n+1\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\nonumber
(\rho v)_i^{n+1} &amp; =  (\rho v)_i^n + {\Delta t\over 2} g_i^{n+1}
  \left(\rho_i^n + \rho_i^{n+1}\right)\\
(\rho E)_i^{n+1} &amp; =  (\rho E)_i^n + {\Delta t\over 4} g_i^{n+1}
  \left(\rho_i^n + \rho_i^{n+1}\right)\left(v_i^n + v_i^{n+1}\right)\ .\end{aligned}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(g_i^{n+1}\)</span> is obtained by extrapolation from
<span class="math notranslate nohighlight">\(\phi_i^{n-1}\)</span> and <span class="math notranslate nohighlight">\(\phi_i^n\)</span>. The <span class="math notranslate nohighlight">\({\tt Poisson}\)</span>
gravity implementation supplies a mesh variable to contain the potential
from the previous timestep; future releases of Flash-X may permit the
storage of several time levels of this quantity for hydrodynamics
algorithms that require more steps. Currently, <span class="math notranslate nohighlight">\({\bf g}\)</span> is
computed at cell centers.</p>
<p>Note that finite-volume schemes do not retain explicit conservation of
momentum and energy when gravity source terms are added. Godunov schemes
such as PPM, require an additional step in order to preserve
second-order time accuracy. The gravitational acceleration component
<span class="math notranslate nohighlight">\(g_i\)</span> is fitted by interpolants along with the other state
variables, and these interpolants are used to construct
characteristic-averaged values of <span class="math notranslate nohighlight">\({\bf g}\)</span> in each cell. The
velocity states <span class="math notranslate nohighlight">\(v_{L,i+1/2}\)</span> and <span class="math notranslate nohighlight">\(v_{R,i+1/2}\)</span>, which are
used as inputs to the Riemann problem solver, are then corrected to
account for the acceleration using the following expressions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\nonumber
v_{L,i+1/2} &amp;\rightarrow&amp; v_{L,i+1/2} + {\Delta t\over
4}\left(g^+_{L,i+1/2} +
  g^-_{L,i+1/2}\right)\\
v_{R,i+1/2} &amp;\rightarrow&amp; v_{R,i+1/2} + {\Delta t\over
4}\left(g^+_{R,i+1/2} +
  g^-_{R,i+1/2}\right)~.\end{aligned}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(g^\pm_{X,i+1/2}\)</span> is the acceleration averaged using the
interpolant on the <span class="math notranslate nohighlight">\(X\)</span> side of the interface (<span class="math notranslate nohighlight">\(X=L,R\)</span>) for
<span class="math notranslate nohighlight">\(v\pm c\)</span> characteristics, which bring material to the interface
between cells <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(i+1\)</span> during the timestep.</p>
</section>
<section id="tree-gravity">
<h3>Tree Gravity<a class="headerlink" href="#tree-gravity" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Tree</span></code> implementation of the gravity unit in
<code class="docutils literal notranslate"><span class="pre">physics/Gravity/GravityMain/Poisson/BHTree</span></code> is meant to be used
together with the tree solver implementation
<code class="docutils literal notranslate"><span class="pre">Grid/GridSolvers/BHTree/Wunsch</span></code>. It either calculates the
gravitational potential field which is subsequently differentiated in
subroutine <code class="docutils literal notranslate"><span class="pre">physics/Gravity/Gravity_accelOneRow</span></code> to obtain the
gravitational acceleration, or it calculates the gravitational
acceleration directly. The latter approach is more accurate, because the
error due to numerical differentiation is avoided, however, it consumes
more memory for storing three components of the gravitational
acceleration. The direct acceleration calculation can be switched on by
specifying <code class="docutils literal notranslate"><span class="pre">bhtreeAcc=1</span></code> as a command line argument of the setup
script.</p>
<p>The gravity unit provides subroutines for building and walking the tree
called by the tree solver. In this version, only monopole moments (node
masses) are used for the potential/acceleration calculation. It also
defines new multipole acceptance criteria (MACs) that estimate the error
in gravitational acceleration of a contribution of a single node to the
potential (hereafter partial error) much better than purely geometrical
MAC defined in the tree solver. They are: (1) the approximate partial
error (APE), and (2) the maximum partial error (MPE). The first one is
based on an assumption that the partial error is proportional to the
multipole moment of the node. The node is accepted for calculation of
the potential if</p>
<div class="math notranslate nohighlight">
\[D^{m+2} &gt; \frac{GMS_\mathrm{node}^m}{\Delta a_\mathrm{p,APE}}\]</div>
<p>where <span class="math notranslate nohighlight">\(D\)</span> is distance between the <em>point-of-calculation</em> and the
node, <span class="math notranslate nohighlight">\(M\)</span> is the node mass, <span class="math notranslate nohighlight">\(S_\mathrm{node}\)</span> is the node
size, <span class="math notranslate nohighlight">\(m\)</span> is a degree of the multipole approximation and
<span class="math notranslate nohighlight">\(\Delta a_\mathrm{p,APE}\)</span> is the requested maximum error in
acceleration (controlled by runtime parameter <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhAccErr</span></code>).
Since only monopole moments are used for the potential calculation, the
most reasonable choice of <span class="math notranslate nohighlight">\(m\)</span> seems to be <span class="math notranslate nohighlight">\(m=2\)</span>. This MAC is
similar to the one used in Gadget2 (see Springel, 2005, MNRAS, 364,
1105).</p>
<p>The second MAC (maximum partial error, MPE) calculates the error in
acceleration of a single node contribution
<span class="math notranslate nohighlight">\(\Delta a_\mathrm{p,MPE}\)</span> according to formula 9 from
Salmon&amp;Warren (1994; see this paper for details):</p>
<div class="math notranslate nohighlight">
\[\Delta a_\mathrm{p,MPE} \le \frac{1}{D^2}\frac{1}{(1-S_\mathrm{node}/D)^2}\left(
\frac{3\lceil B_2\rceil}{D^2} - \frac{2\lfloor B_3 \rfloor}{D^3}\right)\]</div>
<p>where <span class="math notranslate nohighlight">\(B_n = \Sigma_i m_i |\mathbf{r}_i-\mathbf{r}_0|^n\)</span> where
<span class="math notranslate nohighlight">\(m_i\)</span> and <span class="math notranslate nohighlight">\(\mathbf{r}_i\)</span> are masses and positions of
individual grid cells within the node and <span class="math notranslate nohighlight">\(\mathbf{r}_0\)</span> is the
node mass center position. Moment <span class="math notranslate nohighlight">\(B_2\)</span> can be easily determined
during the tree build, moment <span class="math notranslate nohighlight">\(B_3\)</span> can be estimated as
<span class="math notranslate nohighlight">\(B_3^2 \ge
B_2^3/M\)</span>. The maximum allowed partial error in gravitational
acceleration is controlled by runtime parameters
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhAccErr</span></code> and <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhUseRelAccErr</span></code> (see
<a class="reference external" href="#Sec:GravityBHTreeUsing">1.4.1</a>).</p>
<p>During the tree walk, subroutine
<code class="docutils literal notranslate"><span class="pre">physics/Gravity/Gravity_bhNodeContrib</span></code> adds contributions of tree
nodes to the gravitational potential or acceleration fields. In case of
the potential, the contribution is</p>
<div class="math notranslate nohighlight">
\[\Phi = -\frac{GM}{|\vec{r}|}\]</div>
<p>if <code class="docutils literal notranslate"><span class="pre">isolated</span></code> boundary conditions are used, or</p>
<div class="math notranslate nohighlight">
\[\Phi = -GMf_\mathrm{EF,\Phi}(\vec{r})\]</div>
<p>if periodic <code class="docutils literal notranslate"><span class="pre">periodic</span></code> or <code class="docutils literal notranslate"><span class="pre">mixed</span></code> boundary conditions are used. In
case of the acceleration, the contributions are</p>
<div class="math notranslate nohighlight">
\[\vec{a}_g = \frac{GM\vec{r}}{|\vec{r}|^3}\]</div>
<p>for <code class="docutils literal notranslate"><span class="pre">isolated</span></code> boundary conditions, or</p>
<div class="math notranslate nohighlight">
\[\vec{a}_g = GMf_\mathrm{EF,a}(\vec{r})\]</div>
<p>for <code class="docutils literal notranslate"><span class="pre">periodic</span></code> or <code class="docutils literal notranslate"><span class="pre">mixed</span></code> boundary conditions. In In the above
formulae, <span class="math notranslate nohighlight">\(G\)</span> is the constant of gravity, <span class="math notranslate nohighlight">\(M\)</span> is the node
mass, <span class="math notranslate nohighlight">\(\vec{r}\)</span> is the position vector between
<em>point-of-calculation</em> and the node mass center and
<span class="math notranslate nohighlight">\(f_\mathrm{EF,\Phi}\)</span> and <span class="math notranslate nohighlight">\(f_\mathrm{EF,a}\)</span> are the Ewald
fields for the potential and the acceleration (see below).</p>
<p>Boundary conditions can be isolated or periodic, set independently for
each direction. If they are periodic at least in one direction, the
Ewald method is used for the potential calculation (Ewald, P. P., 1921,
Ann. Phys. 64, 253). The original Ewald method is an efficient method
for computing gravitational field for problems with periodic boundary
conditions in three directions. Ewald speeded up evaluation of the
gravitational potential by splitting it into two parts,
<span class="math notranslate nohighlight">\(Gm/r=Gm \, \mathrm{erf}(\alpha r)/r + Gm \, \mathrm{erfc}(\alpha r)/r\)</span>
(<span class="math notranslate nohighlight">\(\alpha\)</span> is an arbitrary constant) and then by applying Poisson
summation formula on erfc terms, gravitational field at position
<span class="math notranslate nohighlight">\(\vec{r}\)</span> can be written in the form</p>
<div class="math notranslate nohighlight">
\[\phi (\vec{r})  =  -G \sum_{a=1}^N m_a \left( \sum_{i_1,i_2,i_3} A_S(\vec{r},\vec{r}_a,\vec{l}_{i_1,i_2,i_3}) +
A_L(\vec{r},\vec{r}_a,\vec{l}_{i_1,i_2,i_3})  \right)
= -G \sum_{a=1}^N m_a f_\mathrm{EF,\Phi}(\vec{r}_a - \vec{r}) \ ,
\label{ewald_sum}\]</div>
<p>the first sum runs over whole computational domain, where at position
<span class="math notranslate nohighlight">\(\vec{r}_a\)</span> is mass <span class="math notranslate nohighlight">\(m_a\)</span>. Second sum runs over all
neigbouring computational domains, which are at positions
<span class="math notranslate nohighlight">\(\vec{l}_{i_1,i_2,i_3}\)</span> and
<span class="math notranslate nohighlight">\(A_S(\vec{r},\vec{r}_a,\vec{l}_{i_1,i_2,i_3})\)</span> and
<span class="math notranslate nohighlight">\(A_L(\vec{r},\vec{r}_a,\vec{l}_{i_1,i_2,i_3})\)</span> are short and
long–range contributions, respectively. It is sufficient to take into
account only few terms in eq. <a class="reference external" href="#ewald_sum">[ewald_sum]</a>. The Ewald
field for the acceleration, <span class="math notranslate nohighlight">\(f_\mathrm{EF,a}\)</span>, is obtained using a
similar decomposition. We modified Ewald method for problems with
periodic boundary conditions in two directions and isolated boundary
conditions in the third direction and for problems with periodic
boundary conditions in one direction and isolated in two directions.</p>
<p>The gravity unit allows also to use a static external gravitational
field read from file. In this version, the field can be either
spherically symmetric or planar being only a function of the
z-coordinate. The external field file is a text file containing three
columns of numbers representing the coordinate, the potential and the
acceleration. The coordinate is the radial distance or z-distance from
the center of the external field given by runtime parameters. The
external field if mapped to a grid using a linear interpolation each
time the gravitational acceleration is calculated (in subroutine
<code class="docutils literal notranslate"><span class="pre">physics/Gravity/Gravity_accelOneRow</span></code>).</p>
</section>
</section>
<section id="usage">
<span id="sec-gravity-usage"></span><h2>Usage<a class="headerlink" href="#usage" title="Permalink to this heading"></a></h2>
<p>To include the effects of gravity in your Flash-X executable, include
the option</p>
<blockquote>
<div><p>-with-unit=physics/Gravity</p>
</div></blockquote>
<p>on your command line when you configure the code with <code class="docutils literal notranslate"><span class="pre">setup</span></code>. The
default implementation is <code class="docutils literal notranslate"><span class="pre">Constant</span></code>, which can be overridden by
including the entire path to the specific implementation in the command
line or <code class="docutils literal notranslate"><span class="pre">Config</span></code> file. The other available implementations are
<code class="docutils literal notranslate"><span class="pre">Gravity/GravityMain/Planepar</span></code>, <code class="docutils literal notranslate"><span class="pre">Gravity/GravityMain/Pointmass</span></code> and
<code class="docutils literal notranslate"><span class="pre">Gravity/GravityMain/Poisson</span></code>. The <code class="docutils literal notranslate"><span class="pre">Gravity</span></code> unit provides accessor
functions to get gravitational acceleration and potential. However, none
of the external field implementations of Section  explicitly compute the
potential, hence they inherit the null implementation from the API for
accessing potential. The gravitation acceleration can be obtained either
on the whole domain, a single block or a single row at a time.</p>
<p>When building an application that solves the Possion equation for the
gravitational potential, additional storage is needed in <code class="docutils literal notranslate"><span class="pre">unk</span></code> for
holding the last, as well as (usually) the previous, gravitational
potential field; and, depending on the Poisson solver used, additional
variables may be needed. The variables <code class="docutils literal notranslate"><span class="pre">GPOT_VAR</span></code> and <code class="docutils literal notranslate"><span class="pre">GPOT_VAR</span></code>,
and others as needed, will be automatically defined in <code class="docutils literal notranslate"><span class="pre">Simulation.h</span></code>
in those cases. See <code class="docutils literal notranslate"><span class="pre">physics/Gravity/Gravity_potentialListOfBlocks</span></code>
for more information.</p>
<section id="tree-gravity-unit-usage">
<span id="sec-gravitybhtreeusing"></span><h3>Tree Gravity Unit Usage<a class="headerlink" href="#tree-gravity-unit-usage" title="Permalink to this heading"></a></h3>
<p>Calculation of gravitational potential can be enabled by compiling in
this unit and setting the runtime parameter <code class="docutils literal notranslate"><span class="pre">Gravity/useGravity</span></code> true.
The constant of gravity can be set independently by runtime parameter
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhNewton</span></code>; if it is not positive, the constant <code class="docutils literal notranslate"><span class="pre">Newton</span></code>
from the Flash-X <code class="docutils literal notranslate"><span class="pre">PhysicalConstants</span></code> database is used. If parameters
<code class="docutils literal notranslate"><span class="pre">Grid/gr_bhPhysMACTW</span></code> or <code class="docutils literal notranslate"><span class="pre">Grid/gr_bhPhysMACComm</span></code> are set, the
gravity unit MAC is used and it can be chosen by setting
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhMAC</span></code> to either <code class="docutils literal notranslate"><span class="pre">ApproxPartialErr</span></code> or
<code class="docutils literal notranslate"><span class="pre">MaxPartialErr</span></code>. If the first one is used, the order of the multipole
approximation is given by <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhMPDegree</span></code>.</p>
<p>The maximum allowed partial error in gravitational acceleration is set
with the runtime parameter <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhAccErr</span></code>. It has either the
meaning of an error in absolute acceleration or in relative acceleration
normalized by the acceleration from the previous time-step. The latter
is used if <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhUseRelAccErr</span></code> is set to True, and in this
case the first call of the tree solver calculates the potential using
purely geometrical MAC (because the acceleration from the previous
time-step does not exist).</p>
<p>Boundary conditions are set by the runtime parameter
<code class="docutils literal notranslate"><span class="pre">Gravity/grav_boundary_type</span></code> and they can be <code class="docutils literal notranslate"><span class="pre">isolated</span></code>,
<code class="docutils literal notranslate"><span class="pre">periodic</span></code> or <code class="docutils literal notranslate"><span class="pre">mixed</span></code>. In the case of mixed boundary conditions,
runtime parameters <code class="docutils literal notranslate"><span class="pre">Gravity/grav_boundary_type_x</span></code>,
<code class="docutils literal notranslate"><span class="pre">Gravity/grav_boundary_type_y</span></code> and <code class="docutils literal notranslate"><span class="pre">Gravity/grav_boundary_type_z</span></code>
specify along which coordinate boundary conditions are periodic and
isolated (possible values are <code class="docutils literal notranslate"><span class="pre">periodic</span></code> or <code class="docutils literal notranslate"><span class="pre">isolated</span></code>). Arbitrary
combination of these values is permitted, thus suitable for problems
with planar resp. linear symmetry. It should work for computational
domain with arbitrary dimensions. The highest accuracy is reached with
blocks of cubic physical dimensions.</p>
<p>If runtime parameter <code class="docutils literal notranslate"><span class="pre">Gravity/grav_boundary_type</span></code> is <code class="docutils literal notranslate"><span class="pre">periodic</span></code> or
<code class="docutils literal notranslate"><span class="pre">mixed</span></code>, then the Ewald field for appropriate symmetry is calculated
at the beginning of the simulation. Parameter
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldSeriesN</span></code> controls the range of indices
<span class="math notranslate nohighlight">\(i_1,i_2,i_3\)</span> in (eq. <a class="reference external" href="#ewald_sum">[ewald_sum]</a>). There are two
implementations of the Ewald method: the new one (default) requires less
memory and it should be faster and of comparable accuracy as the old
one. The default implementation computes Ewald field minus the singular
<span class="math notranslate nohighlight">\(1/r\)</span> term and its partial derivatives on a single cubic grid, and
the Ewald field is then approximated by the first order Taylor formula.
Parameter <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldNPer</span></code> controls number of grid points in
the <span class="math notranslate nohighlight">\(x\)</span> direction in the case of <code class="docutils literal notranslate"><span class="pre">periodic</span></code> or in periodic
direction(s) in the case of <code class="docutils literal notranslate"><span class="pre">mixed</span></code> boundary conditions. Since an
elongated computational domain is often desired when
<code class="docutils literal notranslate"><span class="pre">Gravity/grav_boundary_type</span></code> is <code class="docutils literal notranslate"><span class="pre">mixed</span></code>, the cubic grid would lead
to a huge field of data. In this case, the amount of necessary grid
points is reduced by using an analytical estimate to the Ewald field
sufficiently far away of the symmetry plane or axis.</p>
<p>The old implementation (from Flash4.2) is still present and is enabled
by adding <code class="docutils literal notranslate"><span class="pre">bhtreeEwaldV42=1</span></code> on the setup command line. The Ewald
field is then stored in a nested set of grids, the first of them
corresponds in size to full computational domain, and each following
grid is half the size (in each direction) of the previous grid. Number
of nested grids is controlled by runtime parameter
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldNRefV42</span></code>. If <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldNRefV42</span></code> is too
low to cover origin (where is the Ewald field discontinuous), then the
run is terminated. Each grid is composed of
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldFieldNxV42</span></code> <span class="math notranslate nohighlight">\(\times\)</span>
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldFieldNyV42</span></code> <span class="math notranslate nohighlight">\(\times\)</span>
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhEwaldFieldNzV42</span></code> points. When evaluation of the Ewald
Field at particular point is needed at any time during a run, the field
value is found by interpolation in a suitable level of the grid. Linear
or semi-quadratic interpolation can be chosen by runtime parameter
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhLinearInterpolOnlyV42</span></code> (option <code class="docutils literal notranslate"><span class="pre">true</span></code> corresponds to
linear interpolation). Semi-quadratic interpolation is recommended only
in the case when there are periodic boundary conditions in two
directions.</p>
<p>The external gravitational field can be switched on by setting
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_useExternalPotential</span></code> true. The parameter
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhExtrnPotFile</span></code> gives the name of the file with the
external potential and <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhExtrnPotType</span></code> specifies the
field symmetry: <code class="docutils literal notranslate"><span class="pre">spherical</span></code> for the spherical symmetry and <code class="docutils literal notranslate"><span class="pre">planez</span></code>
for the planar symmetry with field being a function of the z-coordinate.
Parameters <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhExtrnPotCenterY</span></code>,
<code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhExtrnPotCenterX</span></code> and <code class="docutils literal notranslate"><span class="pre">Gravity/grv_bhExtrnPotCenterZ</span></code>
specify the position (in the simulation coordinate system) of the
external field origin (the point where the radial or z-coordinate is
zero).</p>
<div class="center docutils container">
<p>calculation.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravit</span>
<span class="pre">y/grv_bhNewton</span></code></p></td>
<td><p>real</p></td>
<td><p>-1.0</p></td>
<td><p>constant of
gravity; if
<span class="math notranslate nohighlight">\(&lt;\)</span> 0, it
is obtained</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>from internal
physical
constants
database</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gra</span>
<span class="pre">vity/grv_bhMAC</span></code></p></td>
<td><p>string</p></td>
<td><p>“A
pproxPartialErr”</p></td>
<td><p>MAC, other
option:
“MaxPartialErr”</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/</span>
<span class="pre">grv_bhMPDegree</span></code></p></td>
<td><p>integer</p></td>
<td><p>2</p></td>
<td><p>degree of
multipole in
error estimate
in APE MAC</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grv_</span>
<span class="pre">bhUseRelAccErr</span></code></p></td>
<td><p>logical</p></td>
<td><p>.false.</p></td>
<td><p>if .true.,
grv_bhAccErr has
meaning of</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>relative error,
otherwise
absolute</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravit</span>
<span class="pre">y/grv_bhAccErr</span></code></p></td>
<td><p>real</p></td>
<td><p>0.1</p></td>
<td><p>maximum allowed
error in
gravitational</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>acceleration</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="center docutils container">
<p>conditions.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grav</span>
<span class="pre">_boundary_type</span></code></p></td>
<td><p>string</p></td>
<td><p>“isolated”</p></td>
<td><p>or “periodic” or
“mixed”</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grav_b</span>
<span class="pre">oundary_type_x</span></code></p></td>
<td><p>string</p></td>
<td><p>“isolated”</p></td>
<td><p>or “periodic”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grav_b</span>
<span class="pre">oundary_type_y</span></code></p></td>
<td><p>string</p></td>
<td><p>“isolated”</p></td>
<td><p>or “periodic”</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grav_b</span>
<span class="pre">oundary_type_z</span></code></p></td>
<td><p>string</p></td>
<td><p>“isolated”</p></td>
<td><p>or “periodic”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gra</span>
<span class="pre">vity/grv_bhEwald</span>
<span class="pre">AlwaysGenerate</span></code></p></td>
<td><p>boolean</p></td>
<td><p>true</p></td>
<td><p>whether Ewald
field should be
regenerated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grv_</span>
<span class="pre">bhEwaldSeriesN</span></code></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(10\)</span></p></td>
<td><p>number of terms
in the Ewald
series</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/g</span>
<span class="pre">rv_bhEwaldNPer</span></code></p></td>
<td><p>integer</p></td>
<td><p>32</p></td>
<td><p>number of
points+1 of the
Taylor expansion</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/gr</span>
<span class="pre">v_bhEwaldFName</span></code></p></td>
<td><p>string</p></td>
<td><p>“ewald_coeffs”</p></td>
<td><p>file with
coefficients of
the Ewald field
Taylor expansion</p></td>
</tr>
<tr class="row-even"><td><p>`
<cite>Gravity/grv_bhE
waldFieldNxV42`</cite></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(32\)</span></p></td>
<td><p>size of the
Ewald field grid
in x-direction</p></td>
</tr>
<tr class="row-odd"><td><p>`
<cite>Gravity/grv_bhE
waldFieldNyV42`</cite></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(32\)</span></p></td>
<td><p>size of the
Ewald field grid
in y-direction</p></td>
</tr>
<tr class="row-even"><td><p>`
<cite>Gravity/grv_bhE
waldFieldNzV42`</cite></p></td>
<td><p>integer</p></td>
<td><p><span class="math notranslate nohighlight">\(32\)</span></p></td>
<td><p>size of the
Ewald field grid
in z-direction</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grv_</span>
<span class="pre">bhEwaldNRefV42</span></code></p></td>
<td><p>integer</p></td>
<td><p>-1</p></td>
<td><p>number of
refinement
levels (nested
grids) for the
Ewald</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>field; if
<span class="math notranslate nohighlight">\(&lt;\)</span> 0,
determined
automatically</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravi</span>
<span class="pre">ty/grv_bhLinearI</span>
<span class="pre">nterpolOnlyV42</span></code></p></td>
<td><p>logical</p></td>
<td><p>.true.</p></td>
<td><p>if .false.,
semi-quadratic
interpolation is
used for</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>interpolation in
the Ewald field</p></td>
</tr>
<tr class="row-odd"><td><p>``
Gravity/grv_bhEw
aldFNameAccV42``</p></td>
<td><p>string</p></td>
<td><p>”
ewald_field_acc”</p></td>
<td><p>file with the
Ewald field for
acceleration</p></td>
</tr>
<tr class="row-even"><td><p>``
Gravity/grv_bhEw
aldFNamePotV42``</p></td>
<td><p>string</p></td>
<td><p>”
ewald_field_pot”</p></td>
<td><p>file with
coefficients of
the Ewald field
for potential</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<p>Tree gravity unit parameters controlling the external gravitational
field.</p>
<div class="center docutils container">
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Grav</span>
<span class="pre">ity/grv_bhUseExt</span>
<span class="pre">ernalPotential</span></code></p></td>
<td><p>logical</p></td>
<td><p>.false.</p></td>
<td><p>whether to use
external field</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gra</span>
<span class="pre">vity/grv_bhUsePo</span>
<span class="pre">issonPotential</span></code></p></td>
<td><p>logical</p></td>
<td><p>.true.</p></td>
<td><p>whether to use
gravitational
field calculated
by the</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>tree solver</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grv_</span>
<span class="pre">bhExtrnPotFile</span></code></p></td>
<td><p>string</p></td>
<td><p>“externa
l_potential.dat”</p></td>
<td><p>file containing
the external
gravitational
field</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Gravity/grv_</span>
<span class="pre">bhExtrnPotType</span></code></p></td>
<td><p>string</p></td>
<td><p>“planez”</p></td>
<td><p>type of the
external field:
planar or
spherical
symmetry</p></td>
</tr>
<tr class="row-odd"><td><p>`
<cite>Gravity/grv_bhE
xtrnPotCenterX`</cite></p></td>
<td><p>real</p></td>
<td><p>0.0</p></td>
<td><p>x-coordinate of
the center of
the external
field</p></td>
</tr>
<tr class="row-even"><td><p>`
<cite>Gravity/grv_bhE
xtrnPotCenterY`</cite></p></td>
<td><p>real</p></td>
<td><p>0.0</p></td>
<td><p>y-coordinate of
the center of
the external
field</p></td>
</tr>
<tr class="row-odd"><td><p>`
<cite>Gravity/grv_bhE
xtrnPotCenterZ`</cite></p></td>
<td><p>real</p></td>
<td><p>0.0</p></td>
<td><p>z-coordinate of
the center of
the external
field</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="unit-tests">
<span id="sec-gravityunittests"></span><h2>Unit Tests<a class="headerlink" href="#unit-tests" title="Permalink to this heading"></a></h2>
<p>There are two unit tests for the gravity unit. <code class="docutils literal notranslate"><span class="pre">Poisson3</span></code> is
essentially the Maclaurin spheroid problem described in . Because an
analytical solution exists, the accuracy of the gravitational solver can
be quantified. The second test, <code class="docutils literal notranslate"><span class="pre">Poisson3_active</span></code> is a modification of
<code class="docutils literal notranslate"><span class="pre">Poisson3</span></code> to test the mapping of particles in
<code class="docutils literal notranslate"><span class="pre">Grid/Grid_mapParticlesToMesh</span></code>. Some of the mesh density is
redistributed onto particles, and the particles are then mapped back to
the mesh, using the analytical solution to verify completeness. This
test is similar to the simulation <code class="docutils literal notranslate"><span class="pre">PoisParticles</span></code> discussed in .
<code class="docutils literal notranslate"><span class="pre">PoisParticles</span></code> is based on the Huang-Greengard Poisson gravity test
described in .</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sourceTerms.html" class="btn btn-neutral float-left" title="Local Source Terms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Particles.html" class="btn btn-neutral float-right" title="Particles Unit" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Flash-X Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>